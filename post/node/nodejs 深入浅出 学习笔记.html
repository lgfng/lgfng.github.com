<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>听风楼</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="模块机制 核心模块 內建模块 文件模块     .node / .js / .json加载过程：    标识符解析 路径分析 文件定位 [编译分析] 加载执行 require.extensionsprogress.dlopen()progress.binding() v8 gyp工具 libuv 包 NPMNPM官网 包结构package.json bin lib doc test  packag">
<meta property="og:type" content="website">
<meta property="og:title" content="听风楼">
<meta property="og:url" content="http://leafflow.com/post/node/nodejs 深入浅出 学习笔记.html">
<meta property="og:site_name" content="听风楼">
<meta property="og:description" content="模块机制 核心模块 內建模块 文件模块     .node / .js / .json加载过程：    标识符解析 路径分析 文件定位 [编译分析] 加载执行 require.extensionsprogress.dlopen()progress.binding() v8 gyp工具 libuv 包 NPMNPM官网 包结构package.json bin lib doc test  packag">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-07-13T05:00:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="听风楼">
<meta name="twitter:description" content="模块机制 核心模块 內建模块 文件模块     .node / .js / .json加载过程：    标识符解析 路径分析 文件定位 [编译分析] 加载执行 require.extensionsprogress.dlopen()progress.binding() v8 gyp工具 libuv 包 NPMNPM官网 包结构package.json bin lib doc test  packag">
  
    <link rel="alternate" href="/atom.xml" title="听风楼" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">听风楼</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://leafflow.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="page-" class="article article-type-page" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/node/nodejs 深入浅出 学习笔记.html" class="article-date">
  <time datetime="2019-11-20T11:44:53.024Z" itemprop="datePublished">2019-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h1><p> 核心模块<br> 內建模块<br> 文件模块<br>     .node / .js / .json<br>加载过程：<br>    标识符解析 路径分析 文件定位 [编译分析] 加载执行</p>
<p>require.extensions<br>progress.dlopen()<br>progress.binding()<br> v8 gyp工具 libuv</p>
<h2 id="包-NPM"><a href="#包-NPM" class="headerlink" title="包 NPM"></a>包 NPM</h2><p><a href="https://www.npmjs.com/" target="_blank" rel="noopener">NPM官网</a></p>
<h3 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h3><pre><code>package.json
bin
lib
doc
test 
</code></pre><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><pre><code>name
description
version
keywords
maintainers : [{&quot;name&quot;: xxx, &quot;email&quot;: xxx, &quot;web&quot;: xxx}]
contributors :
licenses
repositories
dependencies
其他可选字段：scripts/homepage/os/cpu/engine/builtin/directories/implements
npm 使用额外字段：author、bin、main􀖖devDependencies
</code></pre><h4 id="npm-常用"><a href="#npm-常用" class="headerlink" title="npm 常用"></a>npm 常用</h4><h5 id="install"><a href="#install" class="headerlink" title="install"></a>install</h5><ul>
<li>-g 全局安装<br>根据<code>package.json</code>的 <code>bin</code>字段安装一个全局可用的可执行命令<br>安装目录为：path.resolve(process.execPath, ‘..’, ‘..’, ‘lib’, ‘node_modules’);</li>
<li>本地安装<br>包含package.json的归档文件， 或者目录， 或者链接.<br>npm install <file | url folder></file></li>
<li>非官方源<br>npm install xxx –registry=<url><br>npm config set registry <url><h5 id="钩子命令"><a href="#钩子命令" class="headerlink" title="钩子命令"></a>钩子命令</h5>可通过在 <code>package.json</code> 的<code>scripts</code>中配置钩子脚本，在执行npm命令的时候该脚本会被执行。如：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts":&#123;</span><br><span class="line">    "test":"test.js",</span><br><span class="line">    "install":"install.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</url></url></li>
</ul>
<h5 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h5><p>npm init<br>npm adduser<br>npm publish <folder><br>npm owner <ls | add rm></ls></folder></p>
<h5 id="分析包"><a href="#分析包" class="headerlink" title="分析包"></a>分析包</h5><p>npm ls 分析当前路径下课找到的所有包，生成依赖树</p>
<h5 id="如何考察一个包"><a href="#如何考察一个包" class="headerlink" title="如何考察一个包"></a>如何考察一个包</h5><p>良好的测试<br>良好的文档<br>良好的测试覆盖率<br>良好的编码规范<br>其他</p>
<h1 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h1><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>Windows下基于IOCP， *nix 基于多线程创建<br>Windows中的系统调用过程：<br>调用过程: js调用 –&gt; 生成请求对象 –&gt; 设置参数和回调函数 –&gt; 加入线程池等待执行 –&gt; 调用返回。<br>线程池执行： 线程可用 –&gt; 执行完毕–&gt; 设置结果 –&gt; 通过IOCP –&gt; 释放线程。<br>事件循环： 检查IOCP –&gt; 获取完成的请求对象给观察者 –&gt; 从观察者获取回调函数和结果 –&gt; 执行回调。</p>
<p>核心概念: 时间循环， 线程池， 观察者， 请求对象。</p>
<h2 id="非IO异步API"><a href="#非IO异步API" class="headerlink" title="非IO异步API"></a>非IO异步API</h2><p>setTimeout        //放入红黑树中，循环时检查时间到了，拿出来执行<br>setInterval       //同上<br>setImmediate      //每轮事件循环只会执行一个immediate，立马进入下一个循环。<br>process.nextTick  //在事件循环的最开始执行</p>
<p>idle观察者 &gt; IO观察者 &gt; check 观察者</p>
<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p>EventEmitter();<br>EventProxy();</p>
<h2 id="Promises-Deferred"><a href="#Promises-Deferred" class="headerlink" title="Promises/Deferred"></a>Promises/Deferred</h2><p>Q<br>when</p>
<h2 id="流程控制库"><a href="#流程控制库" class="headerlink" title="流程控制库"></a>流程控制库</h2><h3 id="尾触发与next"><a href="#尾触发与next" class="headerlink" title="尾触发与next"></a>尾触发与next</h3><p>Connect 一个http库， 能已切面的形式，流式处理每一个步骤。</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><h3 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h3><h3 id="wind"><a href="#wind" class="headerlink" title="wind"></a>wind</h3><h2 id="过载保护"><a href="#过载保护" class="headerlink" title="过载保护"></a>过载保护</h2><p>异步API， 可能会快速消耗系统资源， 所以需要控制。</p>
<h3 id="bagpip"><a href="#bagpip" class="headerlink" title="bagpip"></a>bagpip</h3><h3 id="async-1"><a href="#async-1" class="headerlink" title="async"></a>async</h3><p>async.parallelLimit()<br>async.queue()</p>
<h1 id="内存控制"><a href="#内存控制" class="headerlink" title="内存控制"></a>内存控制</h1><h2 id="V8内存限制"><a href="#V8内存限制" class="headerlink" title="V8内存限制"></a>V8内存限制</h2><p>64位系统约为 1.4G, 32位系统约为 0.7G</p>
<h2 id="V8对象分配"><a href="#V8对象分配" class="headerlink" title="V8对象分配"></a>V8对象分配</h2><p>所有对象都是通过堆来分配。<br>查看V8内存使用量: provess.memoryUsage()<br>限制原因是因为垃圾回收机制， 对于过大的堆内存， V8垃圾回收时间太长。<br>当然， 也可以通过以下命令来放开，程序运行时生效，中途不能修改。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node --max-old-space-size=<span class="number">1700</span> test.js  <span class="comment">//单位为 MB</span></span><br><span class="line">node --max-<span class="keyword">new</span>-space-size=<span class="number">1700</span> test.js  <span class="comment">//单位为 KB</span></span><br></pre></td></tr></table></figure></p>
<h2 id="V8垃圾回收机制"><a href="#V8垃圾回收机制" class="headerlink" title="V8垃圾回收机制"></a>V8垃圾回收机制</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>分代式垃圾回收机制， 根据对象的存活时间，进行不同的分代， 不同的分代使用不同的垃圾回收算法。<br>V8中， 内存主要分为新生代和老生代。新生代为存活时间短的对象， 老生代为存活时间教长的对象， 或常驻内存的对象。<br>以上两条命令， 分别用于设置这两个分代的内存空间。</p>
<h4 id="Scavenge算法"><a href="#Scavenge算法" class="headerlink" title="Scavenge算法"></a>Scavenge算法</h4><p>新生代主要使用Scavenge算法，具体实现主要采用了Cheney算法。<br>将内存一分为2，其中一个处于使用状态， 另一个处于空闲状态。<br>垃圾回收时，将使用状态内存中的存活对象拷贝到空闲状态的内存中， 然后交换两个内存块的角色。<br>因为对于新生代对象生命周期短， 所以存活对象少， 效率很高。 <strong>典型的空间换时间</strong><br>因为V8使用分代机制， 所以在一定条件下， 会被移入老生代内存中。</p>
<ol>
<li>当一个对象多次在拷贝过程中存活。</li>
<li>目标内存块利用率超过25%，因为该内存块是接下来的使用块， 所以内存占比过高， 会影响接下来的内存分配。<h4 id="Mark-Sweep-Mark-Compact"><a href="#Mark-Sweep-Mark-Compact" class="headerlink" title="Mark-Sweep + Mark-Compact"></a>Mark-Sweep + Mark-Compact</h4>新生代回收时全停顿<br>老生代增加了增量标记，延迟清理与增量整理等策略，来防止应用逻辑中断时间过长。<h3 id="垃圾回收日志"><a href="#垃圾回收日志" class="headerlink" title="垃圾回收日志"></a>垃圾回收日志</h3>在启动时添加<code>--trace_gc</code>参数，可以在标准输出中打印垃圾回收的日志信息。<br>启动时添加<code>--prof</code>参数， 可得到<code>V8</code>的性能分析数据， 其中包括垃圾回收占用时间。可以在目录下得到一个<code>V8.log</code>文件。<br>使用<code>linux-ticj-processor</code>工具打开该日志文件可以统计日志信息，windows对应文件为<code>windows-tick-processor.bat</code>。</li>
</ol>
<h2 id="高效使用内存"><a href="#高效使用内存" class="headerlink" title="高效使用内存"></a>高效使用内存</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域链<br>变量主动释放： 使用delete 或者给变量赋值为undefined。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包有可能会导致作用域内的变量无法被回收。</p>
<h2 id="内存指标"><a href="#内存指标" class="headerlink" title="内存指标"></a>内存指标</h2><h3 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h3><p>process.memoryUsage()<br>os.totalmem()<br>os.freemem()</p>
<h4 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h4><p>Buffer对象不同于其他对象， 不经过V8的内存分配机制，有Node自行分配，所以不会有内存大小限制。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存一般使用键值对来实现，这样当缓存内容过多的时候， 如果没有合适的清理机制， 缓存会占用大量内存不会被释放。<br>而且进程间无法共享内存，所以多个进程的缓存不会共享， 这也会造成内存浪费。<br>应该使用redis或者memcache等缓存数据库。</p>
<h3 id="未及时消费的队列"><a href="#未及时消费的队列" class="headerlink" title="未及时消费的队列"></a>未及时消费的队列</h3><p>采用更高效的队列消费方案<br>监控并限制队列的长度，当发生堆积时，产生警报并通知相关人员。<br>异步调用添加超时机制， 限定时间未完成， 则通过回调传递超时异常。</p>
<h3 id="作用域未释放"><a href="#作用域未释放" class="headerlink" title="作用域未释放"></a>作用域未释放</h3><h2 id="内存泄漏排查"><a href="#内存泄漏排查" class="headerlink" title="内存泄漏排查"></a>内存泄漏排查</h2><p>V8-profiler<br>node-heapdump<br>node-mtrace<br>dtrace<br>node-memwatch</p>
<h2 id="大内存应用"><a href="#大内存应用" class="headerlink" title="大内存应用"></a>大内存应用</h2><p>stream 模块<br>fs.createReadStream()<br>fs.createWriteStream()</p>
<h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><p>Buffer模块是一个典型的JavaSctipt与C++结合的模块， 性能相关部分用C++实现，非性能部分使用JavaScript实现。</p>
<h3 id="Buffer-对象"><a href="#Buffer-对象" class="headerlink" title="Buffer 对象"></a>Buffer 对象</h3><p>Buffer存储结构类似于数组，它的元素是16进制的两位数， 范围从0-255.不同编码的字符占用的元素个数不相同，汉字占3个元素，字母占1个元素。<br>Buffer对象初始化之后，其中是一个0-255之间的随机值。<br>可以通过下标给Buffer赋值，它会将该值取余到 0-255之间，并取整，然后存入数组。</p>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>C++层面申请内存， javascript层面分配内存， 分配策略使用slab机制。<br>每次至少分配8K的内存， Node以8K为界限来区分Buffer是大对象还是小对象。</p>
<h4 id="小BUffer对象"><a href="#小BUffer对象" class="headerlink" title="小BUffer对象"></a>小BUffer对象</h4><p>对于小Buffer对象， Node会先分配一个8K的SlowBuffer， 这就是一个slab单元，使用一个局部变量pool指向它。<br>然后将buffer对象的parent属性指向该pool，并记录下起始使用位置。<br>之后再次分配的时候，会去检查slab对象中是否还有足够的空间，如果有，则继续从这个slab对象中分配内存给buffer对象使用。<br>如果剩余空间不足，则重新分配一个slab单元，并标记。</p>
<h4 id="大Buffer对象"><a href="#大Buffer对象" class="headerlink" title="大Buffer对象"></a>大Buffer对象</h4><p>对于大Buffer对象，则会直接分配一个指定大小的SlowBuffer对象为slab单元， 这个slab单元会被这个Buffer对象独占。</p>
<h2 id="Buffer转换"><a href="#Buffer转换" class="headerlink" title="Buffer转换"></a>Buffer转换</h2><p>Buffer对象可以与字符串之间相互转换，目前支持的字符串编码类型有以下几种：</p>
<ul>
<li>ascall</li>
<li>utf-8</li>
<li>utf-16le/ucs-2</li>
<li>Base64</li>
<li>Binary</li>
<li>Hex<h3 id="字符串转Buffer"><a href="#字符串转Buffer" class="headerlink" title="字符串转Buffer"></a>字符串转Buffer</h3><figure class="highlight plain"><figcaption><span>Buffer(str, [encoding]);```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">encoding 不传递时， 默认使用utf-8编码进行转码和存储。</span><br><span class="line">同一个Buffer对象可以存储不同编码类型的字符串转码， 可以通过write()方法实现。</span><br><span class="line">buff.write(string, [offset], [length], [encoding])</span><br><span class="line">### Buffer转字符串</span><br><span class="line">Buffer对象的toString()可以将Buffer对象转换为字符串。</span><br><span class="line">```buff.toString([encoding],[start],[end]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以指定编码，和起止位置。 这样可以达到整体或局部转换的效果。<br>如果Buffer对象由多种编码写入，就需要在局部指定不同的编码， 才能转换成正常的编码。</p>
<h3 id="Buffer不支持的编码类型"><a href="#Buffer不支持的编码类型" class="headerlink" title="Buffer不支持的编码类型"></a>Buffer不支持的编码类型</h3><p>Buffer.isEncoding(encoding)</p>
<h4 id="iconv"><a href="#iconv" class="headerlink" title="iconv"></a>iconv</h4><p>调用C++库libiconv完成。</p>
<h4 id="iconv-lite"><a href="#iconv-lite" class="headerlink" title="iconv-lite"></a>iconv-lite</h4><p>纯JavaScript实现， 比iconv更轻量， 更高效。</p>
<h2 id="Buffer-拼接"><a href="#Buffer-拼接" class="headerlink" title="Buffer 拼接"></a>Buffer 拼接</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data += buffer</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">data = data.toString() + buffer.toString()</span><br></pre></td></tr></table></figure>
<p>当buffer使用宽字符的时候，有可能存在被截断的情况，就会出现乱码。</p>
<h3 id="setEncoding-与string-decoder"><a href="#setEncoding-与string-decoder" class="headerlink" title="setEncoding() 与string_decoder()"></a>setEncoding() 与string_decoder()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">该方法的作用是让data事件传递的不再是Buffer对象， 而是使用指定编码编码后的字符串， 所以不会出现乱码问题。</span><br><span class="line">setEncoding 时， 内部会保存一个string_decoder对象， 该对象在编码时， 如果有发现被截断的部分， 会保存在内部， 下次write时，再追加在一起编码。</span><br><span class="line">但是它目前只能处理utf-8, base64和ucs-2/utf-16le这三种编码， 所以不能根本性解决问题。</span><br><span class="line">### 终极方案</span><br><span class="line">用数组来存储收到的所有Buffer片段， 并记录下所有片段的总长度， 然后调用`Buffer.concat()`合成为一个大Buffer对象。</span><br><span class="line">然后在使用指定的编码方式或者iconv转换成字符串。</span><br><span class="line">```javascript</span><br><span class="line">    let chunks=[];</span><br><span class="line">    let size = 0;</span><br><span class="line">    res.on(&apos;data&apos;, （chunk）=&gt;&#123;</span><br><span class="line">        chunks.push(chunk);</span><br><span class="line">        size += chunk.length;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.on(&apos;end&apos;, ()=&gt;&#123;</span><br><span class="line">        const buffer = Buffer.concat(chunks, size);</span><br><span class="line">        const str = iconv.decode(buffer, &apos;utf8&apos;);</span><br><span class="line">        console.log(str);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Buffer-与性能"><a href="#Buffer-与性能" class="headerlink" title="Buffer 与性能"></a>Buffer 与性能</h2><p>在网络传输中使用Buffer能大幅提高传输速率。</p>
<h3 id="静态内容"><a href="#静态内容" class="headerlink" title="静态内容"></a>静态内容</h3><p>静态内容预先转换为Buffer 的方式， 直接读取传输， 不需要做额外的转换， 能减少CPU的重复运算。</p>
<h3 id="文件读取-与-highWaterMark-参数"><a href="#文件读取-与-highWaterMark-参数" class="headerlink" title="文件读取 与 highWaterMark 参数"></a>文件读取 与 highWaterMark 参数</h3><p>对于大文件而言， highWaterMark越大， 读取速度越快。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://leafflow.com/post/node/nodejs 深入浅出 学习笔记.html" data-id="ck552ryj400032ks6h4sawuej" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    

  
    
  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 vollen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>