## 设备名称
linux 中一切都是文件， 所有的设备文件都在 `/dev` 目录下
### 磁盘
磁盘：/dev/sd[a-p]
虚拟磁盘： /dev/vd[a-p]
磁盘的第一个扇区被用来记录磁盘的启动程序 (MBR) 和分区表，大小只有 512B。
### 主分区 或 延伸分区
分区表占用 64B, 因为每个分区要记录起始和结束位置， 所以分区表最多只能记录 4 个分区。这几个分区被作为主分区 或延伸分区。这几个分区的设备名称为 /dev/sda[1-4]。
+ 延伸分区最多只能有一个。
### 逻辑分区
延伸分区可以再次划分，划分出来的分区被称为逻辑分区。逻辑分区的设备号为： /dev/sda[5-] , 设备名称号码从 5 开始， 因为 4 以下留给主分区了。

+ 主分区和逻辑分区可以被格式化之后作为数据存储区， 延伸分区不能直接格式化。

## GPT 分区
GPT 使用34个 LBA 区块来记录分区信息， 第 1 个是 MBR, 第二个用于记录备份区地址， 剩下 32 个用于记录分区表。
在磁盘的最后位置还有分区表的备份信息。
每个分区的起始和结束地址有 64 位来表示，因此每个分区可以达到 2^64 * 512B 大小。

# 开机启动流程
1. BIOS 开机启动的第一个程序， 会读取 MBR 程序执行。
2. MBR 磁盘第一个扇区的程序， 内含开机管理程序。
3. boot loader 开机管理程序， 一个用来加载核心文件的程序。
4. 核心文件 开始操作系统的功能。
因为 MBR 只有很小的空间， 所以要使用 grub 来启动的话， 还必须有一个 【BIOS boot】 分区， 用于存放其他开机程序。

## boot loader 的作用
1. 提供选单，用户可以选择不同的开机项目。
2. 加载核心文件，指向可开机的程序区块来启动操作系统。
3. 加载其他 Loader, 将开机管理程序交给其他 loader, 用于多系统。

如果要装双系统的话， 应该先装 Windows 在安装 linux, 否则 Windows 会覆盖 MBR, 而且没法识别 linux.

## FHS 文件系统结构标准
### / 根目录
根目录
+ /bin  放置常用与用户无关的命令
+ /boot 放置启动相关文件
- /boot/grub2 grub2 开机程序目录
+ /dev 设备与接口文件
+ /etc 一些配置文件， 通常所有用户都可以查看， 只有 root 可修改
- /etc/opt 第三方辅助软件 /opt 的配置
- /etc/x11  与 x window 相关的配置
- /etc/sgml
- /etc/xml 与 xml 格式相关的配置
+ /lib 开机需要的库文件， 或者 /bin /sbin 目录的程序用到的库文件
- /lib/modules 放置可替换式核心交互模块、驱动程序
+ /media 可移除设备
+ /mnt 暂时挂载的目录
+ /opt 第三方辅助软件
+ /run 程序运行后产生的各种信息
+ /sbin root 用户才能使用的设定系统环境的一些命令
+ /srv 一些网络服务程序启动后需要访问的目录
+ /tmp 程序运行时产生的临时文件， 需要时常清理
+ /usr 见下文
+ /var 见下文
#### 建议存在的目录
+ /home  用户目录
+ /lib<qual> 与 /lib 目录不一样的二进制函数库， 如 /lib64 
+ /root  root 用户目录

#### 其他 linux 目录
+ /lost+found ext2/ext3/ext4 文件系统下有的， 用于保存文件系统错误时，丢失的数据片段
+ /proc 一个虚拟文件系统， 所有的数据都是在内存中的。
+ /sys 与 /proc 类似， 不过记录的是 核心与系统硬件相关的信息。 

### /usr 目录
unix software resource 与软件安装执行有关， 里面的文件属于 可分享、 不可变动的。
+ /usr/bin
+ /usr/lib
+ /usr/sbin
+ /usr/local
+ /usr/share
#### 建议有的
+ /usr/include
+ /usr/src
### /var 目录
variable 与系统运行有关， 里面的文件属于 不可分享，可变动的。
+ /var/cache
+ /var/log 登录相关
+ /var/lock --> /run/lock
+ /var/run  --> /run
+ /var/spool
+ /var/mail

## 文件与目录管理
+ basename \`pwd\` 查看当前目录名
+ dirname \`pwd\`  当前目录父目录名
+ cat  由第一行開始顯示檔案內容
+ tac  從最後一行開始顯示，可以看出 tac 是 cat 的倒著寫！
+ nl   顯示的時候，順道輸出行號！
+ more 一頁一頁的顯示檔案內容
+ less 與 more 類似，但是比 more 更好的是，他可以往前翻頁！
+ head 只看頭幾行
+ tail 只看尾巴幾行
+ od   以二進位的方式讀取檔案內容！

### 权限
对于不同的用户， 有独立的权限，共分为三种权限组。
+ u 所属 user
+ g 所属 group
+ o 除以上外其他用户
对于每个权限组， 又有 r(可读)、w(可写)、x(可执行) 三个分量， 对于目录来说，x 权限代表可进入。

使用 `ls -l` 可以查看文件的权限信息， 最前面有十位，第一位表示文件的类型。后面 9 位分别为三个权限组的三个分量。

`chown` 修改文件的所有者
`chgrp` 修改文件所属群组
`chmod` 修改文件的权限信息

### 隐藏属性
`lsattr` 和 `chattr` 可以查看和修改文件的的隐藏属性。
+ a 表示该文件内容只能往后增加，不能修改
+ i 该文件不能被重命名和删除
上面这两个标志位只能使用 root 权限来修改。
还有很多隐藏属性标志位， 可以通知 `man chattr` 来查看。

### 预设权限
`umask` 可以查看文件的预设权限， 预设权限表示新建一个新文件的时候， 它的默认权限是怎样的。
+ 默认最大权限
因为文件一般不可执行， 所以文件的最大权限是 666, 即 rw-rw-rw .
目录通常可以被访问， 所以目录的最大权限是 777, 即 rwxrwxrwx .

umask 的分数是指从默认最大权限中需要减掉的权限。
普通用户的默认 umask 值为 002, root 用户因为权限比较重要， 所以默认值为 022 .
对于普通用户默认 umask， 因为拿掉 other 组的 w 权限。
所以文件的默认权限为 -rw-rw-r-- , 目录的默认权限为 drwxrwxr-x 。

### 特殊权限
除了上面的 rwx 权限外， 文件还可以有 s t 属性。

### SUID
当 s 属性出现在 user 位置时，为 SUID.
+ 仅对二进制程序有效
+ 需要用户对文件有 x 权限
+ s 权限仅在文件执行过程中有效
+ 执行者在执行程序过程中， 有 user 所拥有的权限。
### SGID
当 s 属性出现在 group 位置时，为 SGID.
SGID 可以设给文件和目录。
当设给文件时， 与 SUID 类似， 不过执行中有 group 的权限。
当设给目录时:
+ 需要用户对目录有 x 权限
+ 进入该目录后， 用户的有效 group 为目录的 group
+ 如果用户对目录有 w 权限， 则该用户新建的文件所属 group 与目录 group 一致。
### SBIT
SBIT 只对目录有效。
当用户对目录有 w 和 x 权限时，用户所建立的文件只有 root 和用户自己能删除它。别的用户无法对该文件作删除、移动、重命名操作。

### 给文件添加特殊权限
通过 `chmod` 可以设置文件的特殊权限。
当 chmod 的权限数字是三位时，设置的是普通权限。 如果权限数字有 4 位， 那么第 1 位为特殊权限。
其中 SUID 分值为 4， SGID 分值为 2, SBIT 分值为 1.
也可以使用 `chmod u+s file` 形式来修改特殊权限。

### 空的特殊权限
当文件有特殊权限， 但是不具备该特殊权限所需的基本权限时， 该特殊权限无法生效， 表示为对应的大写形式。
比如: -rwS------ 表示用户对该文件有 SUID，但是不具备 x 权限, 所 SUID 权限形同虚设。

### 查看文件类型
`file` 命令可以查看文件的文件类型。
`type`

## 查找文件
+ which
只查找 PATH 变量中定义的目录
+ whereis
只查找 /bin /sbin /usr/share/man 等几个特殊目录下的文件。
+ locate
locate 通过建立的数据库来查找文件。
可以通过 `updatedb` 来更新数据库, 数据库文件为 /var/lib/mlocate/mlocate.db .
+ find
最强大的搜索命令， 有很多种不同的选项来定义条件。 但是每一次都是真实的在硬盘中查找， 消耗大，速度慢。

# 文件系统
文件系统需要格式化才能使用， 因为每种不同的系统使用的文件属性/权限都不一样， 所以需要格式化。
`dumpe2fs` 来查看文件系统信息。
`blkid` 查看当前系统中被格式化的设备, 以及格式化信息。
## EXT2
之前 linux 默认是用 EXT* 文件系统，这是一种索引式文件系统，基于 inode 和 block 来管理。
文件的权限以及一些基本属性存储于 inode 中， 数据存储在 block 中, inode 中保存有 block 的序号。
所有的 inode 和 block 在文件系统格式化时已经确定， 之后不再变动， 除非使用 `resize2fs` 命令修改文件系统大小。
在 inode 和 block 之上， 还有 blockgroup 的概念， 用于细化每一部分需要管理的数据量。

EXT2 格式化后， 数据形式如下。
bootsector  blockgroup1  blockgroup2 blockgrou3
其中每个 blockgroup 又包含有：
superblock 档案系统描述 blockbitmap inodebitmap  InodeTable DataBlock

### DataBlock
EXT2 的 block 大小在格式化的时候就已经被确定，有 1K, 2K, 4K 三种大小可选择。每种不同的 block 大小对应的`单一最大文件大小`和`文件系统大小`都不一样。
+ 每个 block 只能有一个文件的数据。
+ 当文件大于 block 的大小时，会使用多个文件系统来存储。 inode 中会记录有所有使用的 block。
+ 当文件小于 block 的大小时，该 block 剩余的空间不会再被使用。
所以需要根据不同的使用需要， 来选择不同的 block 大小。
### innode table
inode 中记录文件的一些基本信息， 如权限，拥有者， 修改时间等。 另外还会有对文件所占用的所有 block 序号。
+ 每个 inode 大小都为 128B。
+ 每个文件只使用一个 inode。
+ 用户访问文件时， 会先使用 inode 的权限记录是否符合，符合才会继续读取文件 block 中的内容。

每个 inode 中只有 128B 的大小, 而每个 block 序号需要 4B，那么文件很大，使用很多 block 时， 怎么存储呢？
inode 使用 11 个直接、一个间接、一个双简接、一个三间接记录区，来记录 block 信息。
间接记录区使用额外的 block 来记录。
所以对于 1K 的 block 大小，一个文件最多可以使用 11 + 256 + 256*256 + 256*256*256 个区块， 这就是该文件系统中的`单一最大文件大小`。
因为 2K 和 4K 中，会有文件系统本身的限制， 所以不能这么简单的计算。
### super block
super block 用于记录整个文件系统的信息。没有 super block， 文件系统就不可用了。
它主要记录的信息有：
+ inode 和 block 总量
+ block 和 inode 的大小
+ 文件系统的是否已挂载，挂载时间等。
+ 每个 blockgroup 中都可能有 super block 信息， 除第一个外， 其他都是备份。
### 档案系统描述(FileSystem Description)
记录每个 blockgroup 的起始结束位置。以及每个区段的起始结束位置。
### inode bitmap, block bitmap
使用 bitmap 来记录的 inode 和 block 的使用情况。
用于快速的查找到空的 inode 和 block， 文件的增加和删除会对应的修改到这两块信息。
