
# 简要
终于有时间把预定了很久的 《unity-shader 入门精要》这本书看完了。 最后再回头来回顾一下整本书的内容， 对不熟悉的部分做一个简单的知识整理。
# 第二章 渲染流水线
渲染流水线的任务是**把3d场景渲染到一张纹理或者屏幕上**。
## 概念化阶段
它分为 `应用阶段`，`几何阶段`，`光栅化阶段`三个阶段。其中每个阶段都是一个流水线， 包含了很多子工作想。
### 应用阶段
粗粒度的剔除工作。
准备渲染需要的几何信息（准备模型数据，设置渲染状态），包括纹理，材质,shader, 等数据，并把这些数据传递到下一阶段。这部分工作通常在 CPU 进行。
### 几何阶段
负责把顶点坐标变换到屏幕空间中， 再交给光栅器处理。
### 光栅化阶段
使用上一阶段的数据来产生屏幕上的像素，并渲染出最终图像。
1. 决定哪些像素应该会被绘制。
2. 对逐顶点数据进行插值，得到逐像素数据
3. 逐像素处理计算
## CPU 与 GPU 通信
1. 把数据加载到显存中
2. 设置渲染状态
3. 调用 DrawCall
## GPU 流水线
主要包含概念化阶段中的`几何阶段`与`光栅化阶段`。包含多个阶段，其中 `顶点着色器`,`几何着色器`,`片元着色器`三个部分是可编程的。剩余的部分也大都是可配置的。
下面这几行，包含了 GPU 流水线的所有阶段。
顶点数据 => 
    顶点着色器 => 曲面细分着色器 => 几何着色器 => 裁剪 => 屏幕映射 => 
    三角形设置 => 三角形遍历 => 片元着色器 => 逐片元操作 =>
    屏幕图像
### 顶点着色器
主要的工作是完成坐标变换，需要把顶点坐标从`模型空间`转换到 `齐次裁剪空间`。
`齐次裁剪空间`的坐标经硬件处理后变换`归一化的设备坐标(NDC)`。
### 裁剪
根据 `NDC` 对可视的图元进行裁剪。不在 ((1,1,1), (-1,-1,-1))立方体内的图元会被裁剪掉。
### 屏幕映射
主要工作是把图元的坐标转换到 `屏幕坐标系`, 会保留 z 坐标。
### 三角形设置，三角形遍历
这两个阶段就是常说的`光栅化`阶段。 
它会根据上面得到的顶点信息，组装成三角形，并检查每个像素是否在一个三角形中。
并使用这个三角形的3个顶点信息对整个覆盖区域的像素进行插值, 得到片元信息，并传递给`片元着色器`使用。
### 片元着色器
片元着色器的任务是根据输入数据，得到一个颜色值。可以是直接从纹理采样得来，也可以经过了光照,雾化处理。
### 逐片元操作
主要任务有:
1. 决定每个片元的可见性, 深度测试，模板测试。
2. 混合。
3. 写入颜色缓冲区

# 第 3 章 unity shader 基础
## shader 与材质
`unity shader` 是对底层硬件平台着色器的封装, 它定义了渲染所需的各种代码， 属性 和状态设置指令。
材质需要使用`shader`, 并且能对`shader`的属性进行设置。unity 提供了材质面板让我们能方便的对 `shader` 的属性进行修改。

### ShaderLab
unity 提供的一种编写 `Unity Shader` 的说明性语言。它使用了一些嵌套在花括号内部的语义来描述一个`Unity Shader`文件的结构。
主要包含以下语义:
1. Properties
```
Properties{
    Name ("display name", PropertyType) = DefaultValue
    //更多属性
}
```
2. Subshader
```
SubShader{
    [Tags]
    [RenderSetUp]
    Pass {
    }
    //other pass
}
```
3. Pass
```
Pass{
    [Name]
    [Tags]
    [RenderSetUp]
    [Code]
}
UsePass "path/SHADERNAME"
GrabPass name
```
4. Fallback
### 表面着色器
表面着色器是`unity`抽象的一种着色器，它让我们按照约定定义一个表面，选用合适的光照模型，并设置一些其他属性， 然后使用这些条件，自动生成出最终的着色器代码。

# 第 5 章 初识 Unity Shader
内置着色器资源可以在`unity`官网下载页面下载。unity 提供了很多变量以及宏，功能函数, 帮助我们更方便的实现出想要的效果。
## CG/HLSL 语义
语义实际上就是一个赋给`Shader`输入和输出的字符串，这个字符串表达这个参数的含义，让 Shader 知道从哪里读取数据，并把数据输出到哪里。
unity 支持的常用语义:
1. 应用阶段传递给顶点着色器:
`POSITION`, `NORMAL`, `TANGENT`, `TEXCOORDn`, `COLOR` 
1. 顶点着色器传递给片元着色器:
`SV_POSITION`, `COLOR0`, `COLOR1`, `TEXCOORD0` - `TEXCOORD7`
3. 片元着色器输出
`SV_Target`
## Debug
1. 使用假色图像
2. Visual Studio
2. FrameDebugger
## shader 编写实践
1. 尽可能使用精度较低的类型
2. 尽可能避免不必要的计算， 或者通过与计算的方式来提供更多的数据
3. 慎用分支和循环
如果不可避免需要使用分支语句，那么:
+ 尽可能把计算向上移动, 从`片元着色器`到`顶点着色器`到`CPU`。
+ 分支条件判断语句中的条件变量最好是常数。
+ 每个分支中包含的操作指令数尽可能少。
+ 分支的嵌套层数尽可能少。
4. 不要除 0

# 第 6 章 Unity 中的基础光照
## 标准光照模型 （Phong 光照模型）
分为四个部分:
+ 自发光 emissive
+ 环境光 ambient
+ 漫反射 diffuse
兰伯特光照模型, 因为漫反射光照符合 `lambert's law`, 反射光强度与表面法线与光源方向之间的夹角的余弦值成正比。
```
    Cdiffuse = (Clight · Mdiffuse) * max(0, n · l)
```
+ 高光反射 specular
`Phong` 模型
```
    r = 2(n · l) * n - l //反射方向
    Cspecular = (Clight · Mspecular) * pow(max(0, v * r), gloss);
```
`Blinn` 模型
避免计算 `r`, 引入 `h = normalize(n + l)`;
```
    Cspecular = (Clight · Mspecular) * pow(max(0, n * h), gloss);
```
## 逐顶点还是逐像素
逐像素着色 `Phong 着色(Phong shading)`
逐顶点着色 `高洛德 着色(Gouraud shading)`
## 半兰伯特(Half Lambert)光照模型
与`兰伯特模型`相比，它没有直接使用 max 操作来防止点积为负值， 而是使用了一个缩放函数来调整点积结果的范围，通常情况下 `a = b = 0.5`;
```
    Cdiffuse = (Clight · Mdiffuse) * (a * (n · l) + b)
```

# 第 7 章 基础纹理
## 单张纹理
使用 `_纹理名_ST` 的方式来声明一个纹理的属性, `xy`存储的缩放值， `zw`存储的偏移值。
使用 `tex2D(纹理名, uv)`来对纹理进行采样。
### 纹理属性
#### Wrap Node
+ Repeat
+ Clamp
#### Filter Mode
+ Point
+ Bilinear
+ Trilinear
纹理被放大时, 采样方法，越往下效果越好，但是消耗也越大。
##### Mip Maps
多级纹理映射， 当纹理缩小的时候， 多个纹理像素对应一个目标像素，也会产生锯齿。 使用 `Mip Maps` 能比较好的解决这个问题。

## 凹凸映射
凹凸映射用来为模型提供更多的细节，能够在不改变顶点位置的情况下，让模型看起来像是 "凹凸不平"的。
### 高度纹理
### 法线纹理
#### 模型空间法线纹理
实现简单
#### 切线空间法线纹理
+ 自由度很高
+ 可以进行 uv 动画
+ 方便复用
+ 方便压缩
大多数情况下， 都是使用切线空间下的法线纹理。
法线主要用于计算表面光照，因为计算光照需要将各个矢量统一在一个坐标空间。因为法线纹理中的法线是存储在`切线空间`的，所以我们有两个选择。
##### 在切线空间下计算
在顶点着色器中，将 `观察方向`和`光源方向` 变换到`切线空间`，然后传到片元着色器中计算。
##### 在世界空间下计算
在顶点着色器中，计算出`切线空间到世界空间的变换矩阵`,然后再片元着色器中使用该矩阵将得到的法线变换到`世界空间`下， 然后参与计算。
第一种方法性能优于第二种方法， 因为计算量更少。
第二种方法通用性优于第一种方法， 因为在实现很多其他效果的时候，都需要将法线变换到`世界空间`下参与计算。

## 渐变纹理
可以用渐变纹理，实现更可控的漫反射效果，比如用在卡通渲染中，可以实现大色块的阴影效果。
只需要在实现的时候，根据半兰伯特值，去渐变纹理中采样，然后用这个值参与漫反射颜色计算即可。
## 遮罩纹理
也是用于美术人员可能更好的控制某个特性的计算， 比如高光反射。 
思路就是将计算需要`表面属性`存储在贴图的某一个通道中， 然后在渲染的时候， 将该信息提取出来参与计算即可。 
一张贴图的多个通道可以存储多种不同的`表面属性`，主要看`shader`中怎么利用。

# 第 8 章 透明效果
## 透明度测试
透明度测试是对于一个像素， 如果一个片元的透明度不满足条件，那么它就会被舍弃。
实现简单， 但是效果很极端，要么完全不透明， 要么完全透明。
不需要什么特殊的处理。
## 透明度混合
但是对于透明物体， 则不能往`深度缓冲`中写入深度值，因为如果启用了， 那么透明物体后面的不透明物体就会在`深度测试`时无法通过，被抛弃掉， 而其实它是可以被看到的。
另外，对于透明物体，`深度测试`时开启的，这意味着当一个不透明物体出现在透明物体的前面是， 它仍然是可以挡住透明物体的。
### 渲染顺序
因为`深度缓冲`的存在， 所以不透明物体不需要关心它的渲染顺序。
对于特定的混合参数，两种不同的颜色进行混合，顺序会影响到最终的颜色值， 所以透明度混合需要保证深度值。
基于上文的描述，渲染引擎通常会对物体进行排序，再渲染
1. 先渲染所有不透明物体，并开启`深度写入` 和`深度测试`, 从前往后渲染， 因为可以通过`深度测试`， 过滤掉很多不需要渲染的片元。
2. 将半透明物体按照他们里摄像机的远近进行排序， 然后从后往前顺序渲染这些半透明物体，并开启他们的`深度测试`，但是关闭`深度写入`。 


#### unity 中的渲染顺序
在 `SubShader` 中使用 `Queue` 标签指定一个索引，索引值越小表示越早被渲染。 `unity`定义了几个默认的渲染队列, 我们也可以根据需要使用任意索引值。
+ BackGround 1000
背景， 如 `skybox`
+ Geometry 2000
默认队列， 不透明物体使用这个队列
+ AlphaTest 2450
半透明测试使用这个队列
+ Transparent 2500
透明物体使用这个队列
+ Overlay 4000 
常用于实现一些叠加效果，如光晕。

### 混合命令
#### 混合等式
混合等式就是将源颜色，目标颜色以及`混合因子`经过运算之后得到目标颜色的过程。
下面是使用`加法操作`进行混合是的混合等式。
```
Orgb = SrcFactor x Srgb + DstFactor x Drgb
Oa = SrcFactorA x Sa + DstFactorA x Da
```
通过 `Blend SrcFactor DstFactor, SrcFactorA DstFactorA` 可以设置混合因子。 `alpha`因子与颜色因子一致时，后半部分可以省略。
支持的混合因子:
+ One
+ Zero
+ SrcColor
+ SrcAlpha
+ DstColor
+ DstAlpha
+ OnMinusSrcColor
+ OnMinusSrcAlpha
+ OnMinusDstColor
+ OnMinusDstAlpha

最常用的普通混合因子组合为 : `Blend SrcAlpha OneMinusSrcAlpha`

#### 混合操作
通过 `BlendOp BlendOperation` 命令设置混合操作。
支持的混合操作用
+ Add
+ Sub
+ RevSub
+ Min
+ Max

### 透明度测试的双面渲染
只需要设置 `Cull Off` 就行了
### 透明度混合的双面渲染
为了保证正面和背面的渲染顺序， 可以使用两个 pass, 第一个 pass 只渲染背面，第二个 pass 只渲染正面。就能保证渲染顺序了

# 第 9 章  更复杂的光照
## unity 渲染路径
### 前向渲染
前向渲染是传统的渲染方式， 也是最常用的渲染路径。
对于每个对象，我们需要渲染该对象的渲染片元，并计算两个缓冲区的信息， 利用深度缓冲来决定片元是否可见， 如果可见， 就更新颜色缓冲区中的颜色值。
对于每个逐像素光源， 都需要进行一次完整的渲染流程。 
如果一个物体在多个逐像素光源的影响区域内， 那么该物体就需要执行多个 Pass, 每个 Pass 计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。
通常，渲染引擎会限制每个物体的逐像素光照的数目。

#### unity 中的前向渲染
unity 中， 前向渲染路径中有三中处理光照的方式: `逐顶点处理`, `逐像素处理`，`球谐函数处理`。
决定一个光源使用哪种处理模式取决于它的类型(`是否Important`)和渲染模式。
在前向渲染中， unity 会根据场景中哥哥光源的设置以及这些光源对物体的影响程度(如距离物体的远近，光照强度)对这些光源进行一个重要度排序。
其中，一定数目的光源会按逐像素的方式处理，然后最多有4个光源按逐顶点的方式处理，剩下的光源可以按SH方式处理。
Unity使用的判断规则如下。
+ 场景中最亮的平行光总是按逐像素处理的。
+ 渲染模式被设置成`Not Important`的光源，会按逐顶点或者SH处理。
+ 渲染模式被设置成`Important`的光源，会按逐像素处理。
+ 如果根据以上规则得到的逐像素光源数量小于`Quality Setting`中的逐像素光源数量(Pixel Light Count)，会有更多的光源以逐像素的方式进行渲染。

#### Base Pass
```
Tags {"LightMode"="ForawdBase"}
#pragma multi_compile_fwdbase
```
一个逐像素的平行光以及所有逐顶点的 SH 的光源，在这个 Pass 计算
可实现的光照效果: 光照纹理，环境光，自发光， 阴影
#### 
```
Tags {"LightMode"="ForawdAdd"}
Blend One One
#pragma multi_compile_fwdadd
```
其他影响该物体的逐像素光源，每个光源执行一次该 Pass
可实现的光照效果: 默认情况下不支持阴影， 不过把编译命令修改为` #pragma multi_compile_fwdadd_fullshadows` 可以开启阴影效果

### 逐顶点的照明渲染路径
其实就是使用了逐顶点的方式来计算光照，在前向渲染中同样可以实现。不同的是， 这个路径， 一个 pass 最多访问到 8 个逐顶点光源。

### 延迟渲染路径
因为当场景中光源数量变多时， 前向渲染路劲的效率会大幅下降。所以延迟渲染重新流行起来。延迟渲染还会使用额外的缓冲区(`G-buffer`)来存储我们关心的表面信息, 如发现，位置，材质属性的。
延迟渲染主要包含两个Pass，在第一个 Pass 中， 我们不进行光照计算，而是仅仅计算哪些片元是可见的， 这主要通过深度缓冲技术来实现。当发现一个片元是可见的。 我们就把它的相关信息存储到 `G-buffer`中。
然后在第二个 Pass 中，我们利用 `G-buffer` 中的各个片元信息， 进行真正的光照计算。
由于真正可见的片元数量远小于场景中的物体包含的渲染片元， 所以能节省大量的光照计算时间。

## unity 光源类型
+ 平行光
+ 点光源
+ 聚光灯

## unity 阴影
在实时渲染中，我们最常使用的是一种名为`Shadow Map`的技术。
这种技术理解起来非常简单，它会首先把摄像机的位置放在与光源重合的位置上，那么场景中该光源的阴影区域就是那些摄像机看不到的地方。而Unity就是使用的这种技术。
在渲染时， 通过把坐标转换到光源空间下， 用 (x,y) 坐标去阴影贴图采样。如果顶点坐标的 `z` 值小于采样得到的 `z` 值， 表示改点位于阴影中。
需要 `Shader` 中或者它的 `FallBack` 中包含`LightMode`被设为`ShadowCaster` 的Pass。
### 透明物体的阴影
#### 透明度测试阴影
+ 将 FallBack 改为 `Transparent/Cutout/VertexLit`, 并且提供 `_Cutoff` 属性用于做透明度测试。
+ 因为正面被半透明测试过滤掉之后， 背面就会漏出来， 但是默认情况下， 物体渲染到深度图和阴影映射纹理中仅考虑物体的正面，所以阴影会显示错误。 
因此需要将 MeshRenderer 组件的 Cast Shadows 属性设为 TwoSide。 才能显示正确的结果。
#### 透明度混合阴影
unity 中所有内置透明度混合的 `Unity Shader`，如 `Transparent/VertextLit`等，都没有包含阴影投射的 Pass, 所以这些半透明物体都不会接受来自其他物体的投影。
因为要为这些半透明产生正确的阴影，需要做更严格的处理，可能会影响性能。 
当然如果我们一定要为它们生成阴影的话，也还是有办法的。 就是将它们的 FallBack 设置为 "VertexLit", "Diffuse" 等。

## 统一管理光照衰减和阴影
1. 引入 "Lighting.cginc" 和 "AutoLight.cginc"
2. 在 v2f 结构体中使用内置宏 `SHADOW_COORDS(idx)`声明阴影坐标。
3. 在顶点着色器中使用内之后 `TRANSFER_SHADOW(o)` 计算并向片元着色器传递阴影坐标。
4. 使用 `UNITY_LIGHT_ATTENYUATION（atten, i, i.worldPos）`内置宏来计算光照衰减和阴影。


# 第 10 章 高级纹理
## 立方体纹理
对立方体纹理采用的时候， 我们需要提供一个三维的纹理坐标。这个方向矢量从立方体中心出发，当它向外延伸，会与立方体相交，采样结果就是由该店计算而来的。
常用于天空盒，或者`环境映射`纹理。

### 创建立方体纹理
使用 `Camera.RenderToCubemap` 函数，可以把该摄像机周围的观察到的场景图像存储到6张图像中， 从而可以创建出该位置上对应的立方体纹理。
### 反射
使用立方体纹理， 可以模拟出金属物体反射周围环境的效果。
原理就是，通过入射光线的方向和表面法线方向来计算反射方向，再利用反射方向对立方体纹理进行采样即可。
在 unity 中，可以使用 `reflect(-worldViewDir, worldNormal)` 计算得到该顶点出的反射方向。
### 折射
#### 斯涅尔定律(Snell's Law)
`$x^p_{ij}$`

<!-- 当光线从 材质1 以入射角θ -->
<!-- $x^p_ {ij}$ -->
<!-- ``` -->
<!-- η<sub>2</sub> * sin(θ1) = η2 * sin(θ2) -->
<!-- ``` -->