<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>听风楼</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="倚楼听风雨，淡看江湖路">
<meta property="og:type" content="website">
<meta property="og:title" content="听风楼">
<meta property="og:url" content="http://vollen.github.io/page/6/index.html">
<meta property="og:site_name" content="听风楼">
<meta property="og:description" content="倚楼听风雨，淡看江湖路">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="听风楼">
<meta name="twitter:description" content="倚楼听风雨，淡看江湖路">
  
    <link rel="alternate" href="/atom.xml" title="听风楼" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">听风楼</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://vollen.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-lua/ltable" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/16/lua/ltable/" class="article-date">
  <time datetime="2020-01-16T04:11:46.645Z" itemprop="datePublished">2020-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte flags;  <span class="comment">/* 1&lt;&lt;p means tagmethod(p) is not present */</span> </span><br><span class="line">  lu_byte lsizenode;  <span class="comment">/* log2 of size of `node' array */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> *<span class="title">metatable</span>;</span></span><br><span class="line">  TValue *<span class="built_in">array</span>;  <span class="comment">/* array part */</span></span><br><span class="line">  Node *node;</span><br><span class="line">  Node *lastfree;  <span class="comment">/* any free position is before this position */</span></span><br><span class="line">  GCObject *gclist;</span><br><span class="line">  <span class="keyword">int</span> sizearray;  <span class="comment">/* size of `array' array */</span></span><br><span class="line">&#125; Table;</span><br></pre></td></tr></table></figure>
<p>Table 的数据结构定义在<code>lobject.h</code>中,</p>
<ul>
<li>flags 标识位, 标识是否设置了对应的metamethod </li>
<li>lsizenode 存储node部分的长度的 log2对数, 使用的时候需要还原回来</li>
<li>metatable 元方法， 定义了一些方法</li>
<li>array 数组部分， 直接存储TValue</li>
<li>node  hash部分</li>
<li>lastfree 永远指向最后一个可用的结点， 当找不到的时候， 需要重新rehash</li>
<li>sizearray 数组部分长度</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul>
<li>luaH_getn<br>  判断</li>
<li>luaH_set<br>  <code>lua_Hset</code>并不真正设置值， 而是返回该key的结点。<br>  先尝试调用<code>luaH_get</code>, 如果返回nil,则使用<code>newkey</code>得到一个新的结点并返回 。</li>
<li>luaH_get</li>
<li>luaH_next</li>
<li>newkey<br>  首先根据key的hash值找到对应位置。然后判断该位置是否被占用<pre><code>如果没有，则直接赋值。 
否则， 判断当前结点的`hash位置`是不是这里
    如果不是，则把它放到合适的位置，放到它自己的主位置， 或者找其他空节点，并调整对应key的结点链表。
    如果是，根据`lastfree`找可用结点。
        如果没有可用结点， 则`rehash`。
        有则插入结点， 并将该结点链接到该key对应的链表末尾。
</code></pre></li>
<li>rehash<br>  统计当前<code>table</code>中key为数字(且在最大数组下标范围内)的结点， 和总的结点数。<br>  然后重新计算需要的数组大小<code>computesizes</code>，并分配内存<code>resize</code>。</li>
</ul>
<h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>看到一段神奇的代码，用于将<code>lua_number(double)</code> 快速转换成<code>int</code>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> luai_Cast &#123; <span class="keyword">double</span> l_d; <span class="keyword">long</span> l_l; &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lua_number2int(i,d) \</span></span><br><span class="line">  &#123; <span class="keyword">volatile</span> <span class="keyword">union</span> luai_Cast u; u.l_d = (d) + <span class="number">6755399441055744.0</span>; (i) = u.l_l; &#125;</span><br></pre></td></tr></table></figure></p>
<p>这块代码能生效的原理是利用了<code>IEEE754</code>标准中对浮点数的存数规则。<br>double在内存中， 占用64个比特位， 使用符号数值表示法。其中:</p>
<ul>
<li>0-51位为尾数部分</li>
<li>52-63位为指数部分<ul>
<li>第63位为指数符号位。</li>
</ul>
</li>
<li>64位为符号位</li>
</ul>
<p>浮点数运算规则: 先对齐指数部分， 然后尾数部分相加，最后规范化。<br>6755399441055744.0 = 00000011 <em> 2^52.<br>所以当一个数与它相加的时候， 指数部分强行对齐到52， 尾数部分右移， 正好将所有的小数点之后的部分移调。<br>例： 8.75 = 1000.11 = 1.00011 </em> 2^3 次方， 对齐到52位后，右移49位，原有尾数保留3位,算上会跟着移下来的那个1， 最后得到<br>0000…1000。小数部分全部被移掉。<br>至于最后达成4舍5入效果， 则是由于CPU的舍入机制决定。</p>
<p>将得到的尾数部分直接强制转换为整型(只会取后32个比特位)，即可得到取整的效果。</p>
<ul>
<li><p>为什么用1.5<em>2^52, 而不是1</em>2^52次方呢？<br>因为当操作的数为负数的时候，使用1*2^52，会出现向最高位借位的情况， 导致最高位不为1，在最后规范化处理的时候， 无法保持指数部分为52. 结果异常。<br>为了使能操作负数，所以需要除了省略的最高位外， 还需要有一个比特位为1. </p>
<p>因为整型只取低32位, 所以尾数部分的高20位都是随意的，只要不全为0就行，<br>所以理论上， 一共有2^20-1 个这样的神奇的数字。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vollen.github.io/2020/01/16/lua/ltable/" data-id="ck5g7xyb7001hwes6wd0lsidd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-lua/lua正则" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/16/lua/lua正则/" class="article-date">
  <time datetime="2020-01-16T04:11:46.645Z" itemprop="datePublished">2020-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.cnblogs.com/whiteyun/archive/2009/09/02/1541043.html" target="_blank" rel="noopener">Lua模式匹配</a></p>
<p>lua string 库使用模式匹配来处理字符串的查找和替换，但是它的正则表达式与一般的POSIX规范的正则表达式不一样。因为要保持程序精简。（只用了500行代码就实现咯）</p>
<h1 id="模式："><a href="#模式：" class="headerlink" title="模式："></a>模式：</h1><ul>
<li>%a                 匹配字母</li>
<li>%c                  匹配控制字符</li>
<li>%d                 数字</li>
<li>%l                  小写字母</li>
<li>%p                 标点字符</li>
<li>%s                    空白符</li>
<li>%u                  大写字母</li>
<li>%w                 字母和数字</li>
<li>%x                     十六进制数字</li>
<li>%z                    代表0的字符</li>
<li>^  一行的开头</li>
<li>$  一行的结束</li>
<li><p>%b<x><y> 匹配以 x 开头, y 结束的字符</y></x></p>
</li>
<li><p>以上字符类的大写，表示该字符类的补集。 比如%A 表示非字母的字符。</p>
</li>
<li>% 是模式中的转义字符（需要转义的特殊字符：( ) . % + - * ? [ ] ^ $ ）， </li>
<li><p>\ 是LUA中字符串的转义字符（ “ , “）</p>
</li>
<li><p>可以用 [] 方括号来定义字符集如 </p>
<ul>
<li>[%w_]   用于匹配字母数字和下划线</li>
<li>[%[%]]  用于匹配 一对方括号</li>
<li>[0-9]    用于匹配数字， 与%d一样</li>
<li>[0-9a-fA-F]  与%x一样，匹配十六进制数字</li>
<li>[^xxx] 不包含后面的字符</li>
</ul>
</li>
<li>在一个字符集的前面加一个 <code>^</code> 可以得到它的补集。</li>
</ul>
<h2 id="模式修饰符"><a href="#模式修饰符" class="headerlink" title="模式修饰符"></a>模式修饰符</h2><ul>
<li>+ 匹配前一字符1次或多次</li>
<li>* 匹配前一字符0次或多次</li>
<li>- 匹配前一字符0次或多次</li>
<li>\? 匹配前一字符0次或1次</li>
</ul>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%a+   匹配一个字母，多个字母，或一个单词</span></span><br><span class="line"><span class="comment">%d+   匹配一个或多个数字</span></span><br><span class="line"><span class="comment">%a*   比%a+ 多匹配一个空白</span></span><br><span class="line"><span class="comment">%a-   与 %a*类似，不过是最短（懒惰）匹配，在能匹配到整个表达式的情况下，取   最短的</span></span><br></pre></td></tr></table></figure>
<h1 id="贪婪与懒惰匹配"><a href="#贪婪与懒惰匹配" class="headerlink" title="贪婪与懒惰匹配"></a>贪婪与懒惰匹配</h1><h1 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h1><ul>
<li><p>捕获机制允许一个模式串中的一部分来匹配目标串种的一部分。写法是模式串中你需要捕获的那部分用()括起来，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> pair = <span class="string">"name = anna"</span></span><br><span class="line"><span class="keyword">local</span> key, value = <span class="built_in">string</span>.<span class="built_in">match</span>(pair, <span class="string">"(%a+)%s*=%s*(%a+)"</span>)</span><br><span class="line"><span class="built_in">print</span>(key, value) <span class="comment">--&gt; name anna</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们也可以将捕获用于模式串自身，”([\”‘])(.-)%1”,这里的%1表示匹配第一个捕获的一份拷贝。</p>
</li>
<li><code>()</code> 捕获的不是空内容， 而是捕获在目标字符串中的位置</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vollen.github.io/2020/01/16/lua/lua正则/" data-id="ck5g7xyb8001iwes6f1igxtl9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux/linux 挂载分区" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/16/linux/linux 挂载分区/" class="article-date">
  <time datetime="2020-01-16T04:11:46.644Z" itemprop="datePublished">2020-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>闲来没事鼓捣系统， 准备从unbuntu14.04 升级到16.04，结果中途升级程序被中断， GG。<br>从子翔处借U盘来重装系统（linux mint）， 系统全部安装在固态硬盘中， 起始并没有将原来的/home分区挂载到新系统上。<br>所以需要手动将原来的home分区挂到系统的home 分区</p>
<p>[参考资料]<a href="http://www.mintos.org/skill/home-partition.html" target="_blank" rel="noopener">http://www.mintos.org/skill/home-partition.html</a></p>
<p>那原来的系统上的home哪去了呢？<br>其实它还在原来的硬盘， 原来的位置上， 我们可以通过挂载它之前所在的分区，来找到它。<br>比如原来home 在 / 下， 硬盘分区为 /dev/sda2<br>则可以通过以下命令<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="regexp">/mnt/</span>root</span><br><span class="line">mount <span class="regexp">/dev/</span>sda2 <span class="regexp">/mnt/</span>root</span><br></pre></td></tr></table></figure></p>
<p>这时候进入 /mnt/root/home， 就能发现挂载之前的文件了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vollen.github.io/2020/01/16/linux/linux 挂载分区/" data-id="ck5g7xyat0018wes6g1ea063a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux/linux 私房菜" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/16/linux/linux 私房菜/" class="article-date">
  <time datetime="2020-01-16T04:11:46.644Z" itemprop="datePublished">2020-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="设备名称"><a href="#设备名称" class="headerlink" title="设备名称"></a>设备名称</h2><p>linux 中一切都是文件， 所有的设备文件都在 <code>/dev</code> 目录下</p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>磁盘：/dev/sd[a-p]<br>虚拟磁盘： /dev/vd[a-p]<br>磁盘的第一个扇区被用来记录磁盘的启动程序 (MBR) 和分区表，大小只有 512B。</p>
<h3 id="主分区-或-延伸分区"><a href="#主分区-或-延伸分区" class="headerlink" title="主分区 或 延伸分区"></a>主分区 或 延伸分区</h3><p>分区表占用 64B, 因为每个分区要记录起始和结束位置， 所以分区表最多只能记录 4 个分区。这几个分区被作为主分区 或延伸分区。这几个分区的设备名称为 /dev/sda[1-4]。</p>
<ul>
<li><p>延伸分区最多只能有一个。</p>
<h3 id="逻辑分区"><a href="#逻辑分区" class="headerlink" title="逻辑分区"></a>逻辑分区</h3><p>延伸分区可以再次划分，划分出来的分区被称为逻辑分区。逻辑分区的设备号为： /dev/sda[5-] , 设备名称号码从 5 开始， 因为 4 以下留给主分区了。</p>
</li>
<li><p>主分区和逻辑分区可以被格式化之后作为数据存储区， 延伸分区不能直接格式化。</p>
</li>
</ul>
<h2 id="GPT-分区"><a href="#GPT-分区" class="headerlink" title="GPT 分区"></a>GPT 分区</h2><p>GPT 使用34个 LBA 区块来记录分区信息， 第 1 个是 MBR, 第二个用于记录备份区地址， 剩下 32 个用于记录分区表。<br>在磁盘的最后位置还有分区表的备份信息。<br>每个分区的起始和结束地址有 64 位来表示，因此每个分区可以达到 2^64 * 512B 大小。</p>
<h1 id="开机启动流程"><a href="#开机启动流程" class="headerlink" title="开机启动流程"></a>开机启动流程</h1><ol>
<li>BIOS 开机启动的第一个程序， 会读取 MBR 程序执行。</li>
<li>MBR 磁盘第一个扇区的程序， 内含开机管理程序。</li>
<li>boot loader 开机管理程序， 一个用来加载核心文件的程序。</li>
<li>核心文件 开始操作系统的功能。<br>因为 MBR 只有很小的空间， 所以要使用 grub 来启动的话， 还必须有一个 【BIOS boot】 分区， 用于存放其他开机程序。</li>
</ol>
<h2 id="boot-loader-的作用"><a href="#boot-loader-的作用" class="headerlink" title="boot loader 的作用"></a>boot loader 的作用</h2><ol>
<li>提供选单，用户可以选择不同的开机项目。</li>
<li>加载核心文件，指向可开机的程序区块来启动操作系统。</li>
<li>加载其他 Loader, 将开机管理程序交给其他 loader, 用于多系统。</li>
</ol>
<p>如果要装双系统的话， 应该先装 Windows 在安装 linux, 否则 Windows 会覆盖 MBR, 而且没法识别 linux.</p>
<h2 id="FHS-文件系统结构标准"><a href="#FHS-文件系统结构标准" class="headerlink" title="FHS 文件系统结构标准"></a>FHS 文件系统结构标准</h2><h3 id="根目录"><a href="#根目录" class="headerlink" title="/ 根目录"></a>/ 根目录</h3><p>根目录</p>
<ul>
<li>/bin  放置常用与用户无关的命令</li>
<li>/boot 放置启动相关文件</li>
</ul>
<ul>
<li>/boot/grub2 grub2 开机程序目录</li>
</ul>
<ul>
<li>/dev 设备与接口文件</li>
<li>/etc 一些配置文件， 通常所有用户都可以查看， 只有 root 可修改</li>
</ul>
<ul>
<li>/etc/opt 第三方辅助软件 /opt 的配置</li>
<li>/etc/x11  与 x window 相关的配置</li>
<li>/etc/sgml</li>
<li>/etc/xml 与 xml 格式相关的配置</li>
</ul>
<ul>
<li>/lib 开机需要的库文件， 或者 /bin /sbin 目录的程序用到的库文件</li>
</ul>
<ul>
<li>/lib/modules 放置可替换式核心交互模块、驱动程序</li>
</ul>
<ul>
<li>/media 可移除设备</li>
<li>/mnt 暂时挂载的目录</li>
<li>/opt 第三方辅助软件</li>
<li>/run 程序运行后产生的各种信息</li>
<li>/sbin root 用户才能使用的设定系统环境的一些命令</li>
<li>/srv 一些网络服务程序启动后需要访问的目录</li>
<li>/tmp 程序运行时产生的临时文件， 需要时常清理</li>
<li>/usr 见下文</li>
<li>/var 见下文<h4 id="建议存在的目录"><a href="#建议存在的目录" class="headerlink" title="建议存在的目录"></a>建议存在的目录</h4></li>
<li>/home  用户目录</li>
<li>/lib<qual> 与 /lib 目录不一样的二进制函数库， 如 /lib64 </qual></li>
<li>/root  root 用户目录</li>
</ul>
<h4 id="其他-linux-目录"><a href="#其他-linux-目录" class="headerlink" title="其他 linux 目录"></a>其他 linux 目录</h4><ul>
<li>/lost+found ext2/ext3/ext4 文件系统下有的， 用于保存文件系统错误时，丢失的数据片段</li>
<li>/proc 一个虚拟文件系统， 所有的数据都是在内存中的。</li>
<li>/sys 与 /proc 类似， 不过记录的是 核心与系统硬件相关的信息。 </li>
</ul>
<h3 id="usr-目录"><a href="#usr-目录" class="headerlink" title="/usr 目录"></a>/usr 目录</h3><p>unix software resource 与软件安装执行有关， 里面的文件属于 可分享、 不可变动的。</p>
<ul>
<li>/usr/bin</li>
<li>/usr/lib</li>
<li>/usr/sbin</li>
<li>/usr/local</li>
<li>/usr/share<h4 id="建议有的"><a href="#建议有的" class="headerlink" title="建议有的"></a>建议有的</h4></li>
<li>/usr/include</li>
<li>/usr/src<h3 id="var-目录"><a href="#var-目录" class="headerlink" title="/var 目录"></a>/var 目录</h3>variable 与系统运行有关， 里面的文件属于 不可分享，可变动的。</li>
<li>/var/cache</li>
<li>/var/log 登录相关</li>
<li>/var/lock –&gt; /run/lock</li>
<li>/var/run  –&gt; /run</li>
<li>/var/spool</li>
<li>/var/mail</li>
</ul>
<h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h2><ul>
<li>basename `pwd` 查看当前目录名</li>
<li>dirname `pwd`  当前目录父目录名</li>
<li>cat  由第一行開始顯示檔案內容</li>
<li>tac  從最後一行開始顯示，可以看出 tac 是 cat 的倒著寫！</li>
<li>nl   顯示的時候，順道輸出行號！</li>
<li>more 一頁一頁的顯示檔案內容</li>
<li>less 與 more 類似，但是比 more 更好的是，他可以往前翻頁！</li>
<li>head 只看頭幾行</li>
<li>tail 只看尾巴幾行</li>
<li>od   以二進位的方式讀取檔案內容！</li>
</ul>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>对于不同的用户， 有独立的权限，共分为三种权限组。</p>
<ul>
<li>u 所属 user</li>
<li>g 所属 group</li>
<li>o 除以上外其他用户<br>对于每个权限组， 又有 r(可读)、w(可写)、x(可执行) 三个分量， 对于目录来说，x 权限代表可进入。</li>
</ul>
<p>使用 <code>ls -l</code> 可以查看文件的权限信息， 最前面有十位，第一位表示文件的类型。后面 9 位分别为三个权限组的三个分量。</p>
<p><code>chown</code> 修改文件的所有者<br><code>chgrp</code> 修改文件所属群组<br><code>chmod</code> 修改文件的权限信息</p>
<h3 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h3><p><code>lsattr</code> 和 <code>chattr</code> 可以查看和修改文件的的隐藏属性。</p>
<ul>
<li>a 表示该文件内容只能往后增加，不能修改</li>
<li>i 该文件不能被重命名和删除<br>上面这两个标志位只能使用 root 权限来修改。<br>还有很多隐藏属性标志位， 可以通知 <code>man chattr</code> 来查看。</li>
</ul>
<h3 id="预设权限"><a href="#预设权限" class="headerlink" title="预设权限"></a>预设权限</h3><p><code>umask</code> 可以查看文件的预设权限， 预设权限表示新建一个新文件的时候， 它的默认权限是怎样的。</p>
<ul>
<li>默认最大权限<br>因为文件一般不可执行， 所以文件的最大权限是 666, 即 rw-rw-rw .<br>目录通常可以被访问， 所以目录的最大权限是 777, 即 rwxrwxrwx .</li>
</ul>
<p>umask 的分数是指从默认最大权限中需要减掉的权限。<br>普通用户的默认 umask 值为 002, root 用户因为权限比较重要， 所以默认值为 022 .<br>对于普通用户默认 umask， 因为拿掉 other 组的 w 权限。<br>所以文件的默认权限为 -rw-rw-r– , 目录的默认权限为 drwxrwxr-x 。</p>
<h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><p>除了上面的 rwx 权限外， 文件还可以有 s t 属性。</p>
<h3 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h3><p>当 s 属性出现在 user 位置时，为 SUID.</p>
<ul>
<li>仅对二进制程序有效</li>
<li>需要用户对文件有 x 权限</li>
<li>s 权限仅在文件执行过程中有效</li>
<li>执行者在执行程序过程中， 有 user 所拥有的权限。<h3 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h3>当 s 属性出现在 group 位置时，为 SGID.<br>SGID 可以设给文件和目录。<br>当设给文件时， 与 SUID 类似， 不过执行中有 group 的权限。<br>当设给目录时:</li>
<li>需要用户对目录有 x 权限</li>
<li>进入该目录后， 用户的有效 group 为目录的 group</li>
<li>如果用户对目录有 w 权限， 则该用户新建的文件所属 group 与目录 group 一致。<h3 id="SBIT"><a href="#SBIT" class="headerlink" title="SBIT"></a>SBIT</h3>SBIT 只对目录有效。<br>当用户对目录有 w 和 x 权限时，用户所建立的文件只有 root 和用户自己能删除它。别的用户无法对该文件作删除、移动、重命名操作。</li>
</ul>
<h3 id="给文件添加特殊权限"><a href="#给文件添加特殊权限" class="headerlink" title="给文件添加特殊权限"></a>给文件添加特殊权限</h3><p>通过 <code>chmod</code> 可以设置文件的特殊权限。<br>当 chmod 的权限数字是三位时，设置的是普通权限。 如果权限数字有 4 位， 那么第 1 位为特殊权限。<br>其中 SUID 分值为 4， SGID 分值为 2, SBIT 分值为 1.<br>也可以使用 <code>chmod u+s file</code> 形式来修改特殊权限。</p>
<h3 id="空的特殊权限"><a href="#空的特殊权限" class="headerlink" title="空的特殊权限"></a>空的特殊权限</h3><p>当文件有特殊权限， 但是不具备该特殊权限所需的基本权限时， 该特殊权限无法生效， 表示为对应的大写形式。<br>比如: -rwS—— 表示用户对该文件有 SUID，但是不具备 x 权限, 所 SUID 权限形同虚设。</p>
<h3 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h3><p><code>file</code> 命令可以查看文件的文件类型。<br><code>type</code></p>
<h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><ul>
<li>which<br>只查找 PATH 变量中定义的目录</li>
<li>whereis<br>只查找 /bin /sbin /usr/share/man 等几个特殊目录下的文件。</li>
<li>locate<br>locate 通过建立的数据库来查找文件。<br>可以通过 <code>updatedb</code> 来更新数据库, 数据库文件为 /var/lib/mlocate/mlocate.db .</li>
<li>find<br>最强大的搜索命令， 有很多种不同的选项来定义条件。 但是每一次都是真实的在硬盘中查找， 消耗大，速度慢。</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>文件系统需要格式化才能使用， 因为每种不同的系统使用的文件属性/权限都不一样， 所以需要格式化。<br><code>dumpe2fs</code> 来查看文件系统信息。<br><code>blkid</code> 查看当前系统中被格式化的设备, 以及格式化信息。</p>
<h2 id="EXT2"><a href="#EXT2" class="headerlink" title="EXT2"></a>EXT2</h2><p>之前 linux 默认是用 EXT* 文件系统，这是一种索引式文件系统，基于 inode 和 block 来管理。<br>文件的权限以及一些基本属性存储于 inode 中， 数据存储在 block 中, inode 中保存有 block 的序号。<br>所有的 inode 和 block 在文件系统格式化时已经确定， 之后不再变动， 除非使用 <code>resize2fs</code> 命令修改文件系统大小。<br>在 inode 和 block 之上， 还有 blockgroup 的概念， 用于细化每一部分需要管理的数据量。</p>
<p>EXT2 格式化后， 数据形式如下。<br>bootsector  blockgroup1  blockgroup2 blockgrou3<br>其中每个 blockgroup 又包含有：<br>superblock 档案系统描述 blockbitmap inodebitmap  InodeTable DataBlock</p>
<h3 id="DataBlock"><a href="#DataBlock" class="headerlink" title="DataBlock"></a>DataBlock</h3><p>EXT2 的 block 大小在格式化的时候就已经被确定，有 1K, 2K, 4K 三种大小可选择。每种不同的 block 大小对应的<code>单一最大文件大小</code>和<code>文件系统大小</code>都不一样。</p>
<ul>
<li>每个 block 只能有一个文件的数据。</li>
<li>当文件大于 block 的大小时，会使用多个文件系统来存储。 inode 中会记录有所有使用的 block。</li>
<li>当文件小于 block 的大小时，该 block 剩余的空间不会再被使用。<br>所以需要根据不同的使用需要， 来选择不同的 block 大小。<h3 id="innode-table"><a href="#innode-table" class="headerlink" title="innode table"></a>innode table</h3>inode 中记录文件的一些基本信息， 如权限，拥有者， 修改时间等。 另外还会有对文件所占用的所有 block 序号。</li>
<li>每个 inode 大小都为 128B。</li>
<li>每个文件只使用一个 inode。</li>
<li>用户访问文件时， 会先使用 inode 的权限记录是否符合，符合才会继续读取文件 block 中的内容。</li>
</ul>
<p>每个 inode 中只有 128B 的大小, 而每个 block 序号需要 4B，那么文件很大，使用很多 block 时， 怎么存储呢？<br>inode 使用 11 个直接、一个间接、一个双简接、一个三间接记录区，来记录 block 信息。<br>间接记录区使用额外的 block 来记录。<br>所以对于 1K 的 block 大小，一个文件最多可以使用 11 + 256 + 256<em>256 + 256</em>256*256 个区块， 这就是该文件系统中的<code>单一最大文件大小</code>。<br>因为 2K 和 4K 中，会有文件系统本身的限制， 所以不能这么简单的计算。</p>
<h3 id="super-block"><a href="#super-block" class="headerlink" title="super block"></a>super block</h3><p>super block 用于记录整个文件系统的信息。没有 super block， 文件系统就不可用了。<br>它主要记录的信息有：</p>
<ul>
<li>inode 和 block 总量</li>
<li>block 和 inode 的大小</li>
<li>文件系统的是否已挂载，挂载时间等。</li>
<li>每个 blockgroup 中都可能有 super block 信息， 除第一个外， 其他都是备份。<h3 id="档案系统描述-FileSystem-Description"><a href="#档案系统描述-FileSystem-Description" class="headerlink" title="档案系统描述(FileSystem Description)"></a>档案系统描述(FileSystem Description)</h3>记录每个 blockgroup 的起始结束位置。以及每个区段的起始结束位置。<h3 id="inode-bitmap-block-bitmap"><a href="#inode-bitmap-block-bitmap" class="headerlink" title="inode bitmap, block bitmap"></a>inode bitmap, block bitmap</h3>使用 bitmap 来记录的 inode 和 block 的使用情况。<br>用于快速的查找到空的 inode 和 block， 文件的增加和删除会对应的修改到这两块信息。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vollen.github.io/2020/01/16/linux/linux 私房菜/" data-id="ck5g7xyau0019wes67p3v53eo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-lang/oc/oc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/16/lang/oc/oc/" class="article-date">
  <time datetime="2020-01-16T04:11:46.644Z" itemprop="datePublished">2020-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>clang -fobjc-arc files -o program</p>
<p>[receiver message ];<br>[receiver message : data, …];</p>
<p>@interface NewClassName : ParentClassName<br>    propertyAndMethodDeclarations;<br>-(returnType) memberFunc:(paramType) param1;<br>+classFunc<br>@end</p>
<p>@implementation NewCalssName<br>{<br>    memberDeclarations;<br>}<br>methodDefinitions;<br>@end</p>
<p>@synthesize 能让编译器自动生成一些内容</p>
<p>分配一个对象， 并进行初始化<br>myFraction = [[Fraction alloc] init];<br>[Class new] 等价于 [[Class alloc] init] </p>
<p>ARC 机制， automatic release counting， 自动引用计数</p>
<p>访问方法名和成员变量名可以一致.</p>
<p>数据类型：<br>int float double char</p>
<p>for( init_expression; loop_condition; loop_expression){<br>    program statement;<br>}</p>
<p>if( expression)<br>    program statement<br>else<br>    statement 2<br>NAN not a number</p>
<p>&amp;&amp; ||</p>
<p>&lt;ctype.h&gt;</p>
<p>&lt;Foundation/Foundation.h&gt;</p>
<p>双引号用于引用本地文件，<br>尖括号用于引用系统文件</p>
<p>合成getter/setter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface Fraction : NSObject</span><br><span class="line">@property int numerator, denominator;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Fraction</span><br><span class="line">@synthesize numerator, denominator;</span><br><span class="line">//如果忽略 @synthesize 指令， 编译器生成的成员变量名会以_开头。</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>instance.property  等价于<br>[instance property]</p>
<p>instance.property = value 等价于<br>[instance setProperty: value]</p>
<p>多参数方法<br>@interface<br>-（void) setTo: (int) n over: (int) d;<br>-(void) set:(int) n: (int)d;<br>@end</p>
<p>@implematation<br>-(void) setTo: (int) n over: (int) d<br>{<br>    numerator = n;<br>    denominator = d;<br>}<br>-(void) set: (int) n over: (int) d<br>{<br>    同上<br>}<br>@end</p>
<p>static<br>方法内局部静态变量<br>文件内局部静态变量</p>
<p>self 关键字</p>
<p>继承<br>在实现部分声明和合成的变量是私有的， 子类不能直接访问。<br>需要在接口部分声明，子类才能访问。</p>
<p>取值方法与直接使用实例变量是不同的， 有可能父类的成员是私有的， 但是暴露了取值方法。</p>
<p>@class 指令<br>当对应的文件只需要知道某类型是否存在而不需要了解他的其他细节时， 可通过@class指令声明。</p>
<p>abstract<br>printf</p>
<p>多态<br>id类型， 可以用来保存任意类型的对象 ， 不需要添加*号。<br>不能对id类型的变量使用点运算符，编译时会出错。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vollen.github.io/2020/01/16/lang/oc/oc/" data-id="ck5g7xyd4007fwes68s4swo0a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jenkins" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/16/jenkins/" class="article-date">
  <time datetime="2020-01-16T04:11:46.643Z" itemprop="datePublished">2020-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://blog.csdn.net/zzusimon/article/details/57080337" target="_blank" rel="noopener">取不到环境变量，[非]登录[非]交互式shll</a><br><a href="https://jenkins.io/zh/doc/pipeline/tour/hello-world/" target="_blank" rel="noopener">中文教程</a><br><a href="https://blog.csdn.net/qq_15807167/article/details/79896131" target="_blank" rel="noopener">设置中文</a></p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul>
<li><a href="https://wiki.jenkins.io/display/JENKINS/Description+Setter+Plugin" target="_blank" rel="noopener">description setter 设置最后输出描述格式</a></li>
<li><a href>Multiple SCMs 多仓库管理</a></li>
</ul>
<h2 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h2><p>在官网下载dmg安装包，安装完毕即可在本机搭建jenkins的工作。但是jenkins不会用本地的用户去构建，任何创建的文件都是“jenkins”用户所有，这会造成很多权限问题，无法调用自己写的脚本，执行shell会出现没有权限的错误。</p>
<h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>查看自己的用户群组和用户名<br>系统偏好设置 -&gt; 用户与群组 -&gt; 点按🔒锁按钮进行更改 -&gt; 输入密码确认 -&gt; 右键高级选项… -&gt; 查看群组和用户名</p>
<h3 id="停止Jenkins"><a href="#停止Jenkins" class="headerlink" title="停止Jenkins"></a>停止Jenkins</h3><p><code>sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist</code></p>
<h3 id="修改-org-jenkins-ci-plist-配置"><a href="#修改-org-jenkins-ci-plist-配置" class="headerlink" title="修改 org.jenkins-ci.plist 配置"></a>修改 org.jenkins-ci.plist 配置</h3><p><code>sudo vi /Library/LaunchDaemons/org.jenkins-ci.plist</code></p>
<ol>
<li>JENKINS_HOME 为 JENKINS 的根目录地址，默认 /Users/Shared/Jenkins/Home/ 需要改到当前用户下 /Users/userName/.jenkins 解决权限问题和工作路径找不到问题；</li>
<li>GroupName 群组名，改为当前用户的群组；</li>
<li>UserName 用户名，改为当前用户的用户名；</li>
</ol>
<h3 id="重启-Jenkins"><a href="#重启-Jenkins" class="headerlink" title="重启 Jenkins"></a>重启 Jenkins</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 Jenkins 本地服务启动失败需要停止当前Jenkins 执行以下操作再重启Jenkins</span></span><br><span class="line">$ sudo chown -R userName /Users/Shared/Jenkins</span><br><span class="line">$ sudo chown -R userName /var/<span class="built_in">log</span>/jenkins</span><br><span class="line"><span class="comment"># 重启Jenkins</span></span><br><span class="line">$ sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动启动脚本</span></span><br><span class="line">sh /Library/Application Support/Jenkins/jenkins-runner.sh</span><br></pre></td></tr></table></figure>
<h2 id="安装-plugins"><a href="#安装-plugins" class="headerlink" title="安装 plugins"></a>安装 plugins</h2><ul>
<li>由于更改了 Jenkins 的根目录所以要重新安装一遍<code>plugins</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vollen.github.io/2020/01/16/jenkins/" data-id="ck5g7xy9k0005wes6t0ds18hr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-json-schema" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/16/json-schema/" class="article-date">
  <time datetime="2020-01-16T04:11:46.643Z" itemprop="datePublished">2020-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>json schema 用于规范约束 json 的格式</p>
<p><a href="https://json-schema.org/" target="_blank" rel="noopener">官网</a><br><a href="https://json-schema.org/understanding-json-schema/index.html" target="_blank" rel="noopener">示例</a><br><a href="http://json-schema.org/latest/json-schema-validation.html" target="_blank" rel="noopener">rfc</a></p>
<h1 id="主要关键字"><a href="#主要关键字" class="headerlink" title="主要关键字"></a>主要关键字</h1><ul>
<li>$schema</li>
<li>$id</li>
<li>type</li>
<li>description</li>
<li>title</li>
<li>required</li>
<li>definitions</li>
</ul>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><code>&quot;type&quot;: &quot;object&quot;</code></p>
<h3 id="keywords"><a href="#keywords" class="headerlink" title="keywords"></a>keywords</h3><ul>
<li>maxProperties</li>
<li>minProperties</li>
<li>required</li>
<li>properties</li>
<li>patternProperties</li>
<li>additionalProperties</li>
<li>dependencies</li>
<li>propertyNames<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><code>&quot;type&quot;: &quot;array&quot;</code><h3 id="keywords-1"><a href="#keywords-1" class="headerlink" title="keywords"></a>keywords</h3></li>
<li>items</li>
<li>additionalItems</li>
<li>maxItems</li>
<li>minItems</li>
<li>uniqueItems</li>
<li>contains<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><h3 id="keywords-2"><a href="#keywords-2" class="headerlink" title="keywords"></a>keywords</h3></li>
<li>multipleOf</li>
<li>maximum</li>
<li>exclusiveMaximum</li>
<li>minimum</li>
<li>exclusiveMinimum<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="keywords-3"><a href="#keywords-3" class="headerlink" title="keywords"></a>keywords</h3></li>
<li>maxLength</li>
<li>minLength</li>
<li>pattern</li>
</ul>
<h1 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h1><ul>
<li>allOf</li>
<li>anyOf</li>
<li>oneOf</li>
<li>not</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>definitions</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vollen.github.io/2020/01/16/json-schema/" data-id="ck5g7xy9l0006wes6ufk5fp8e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-lang/c#" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/16/lang/c#/" class="article-date">
  <time datetime="2020-01-16T04:11:46.643Z" itemprop="datePublished">2020-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h2><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>声明一个命名空间</p>
<h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><p>using 可以在程序中包含命名空间</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li><code>//</code> <code>/* */</code> 可以添加注释</li>
<li><code>///</code> 文档注释<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2></li>
</ul>
<ul>
<li>必须由 数字，字母，下划线(_)，@ 组成</li>
<li>不能由数字开头</li>
<li>@ 只能放在开头</li>
<li>不能与保留字或类库名称相同，可以在前面加上 @ 作为前缀来使用。<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2>变量分为三种类型： 值类型，引用类型，指针类型<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3>值类型直接包含数据，都是从类 System.ValueType 派生而来。<br>可用的值类型： bool, byte(8位无符号整数), char（16位 unicode 字符）, decimal, double, float, int, long, sbyte(8位有符号整数), short, uint, ulong, ushort。<br>sizeof(type) 可以获得一个类型或者变量在指定平台上的准确尺寸。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Sizeof bool : 1</span><br><span class="line">Sizeof byte : 1</span><br><span class="line">Sizeof char : 2</span><br><span class="line">Sizeof decimal : 16</span><br><span class="line">Sizeof double : 8</span><br><span class="line">Sizeof float : 4</span><br><span class="line">Sizeof int : 4</span><br><span class="line">Sizeof long : 8</span><br><span class="line">Sizeof sbyte : 1</span><br><span class="line">Sizeof short : 2</span><br><span class="line">Sizeof uint : 4</span><br><span class="line">Sizeof ulong : 8</span><br><span class="line">Sizeof ushort : 2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型的变量不直接存储数据，但是包含对多个数据引用。 多个不同的变量可以引用同一个数据，一处修改，其他引用也会受到影响。<br>内置的引用类型有：object, dynamic, String</p>
<h4 id="对象类型-object"><a href="#对象类型-object" class="headerlink" title="对象类型 object"></a>对象类型 object</h4><p>object 是 c# 中所有类型的基类，是 System.Object 的别名。<br>任何别的类型都可以转换成 Object 类型。<br>装箱， 一个值类型转换为对象类型。<br>拆箱， 一个对象类型转换为值类型。</p>
<h4 id="动态类型-dynamic"><a href="#动态类型-dynamic" class="headerlink" title="动态类型 dynamic"></a>动态类型 dynamic</h4><p>动态类型的变量可以存储任何类型的值，它的类型检查是在运行时发生的。<br>dynamic 类型用于与其他的 .net 动态脚本交互。</p>
<h4 id="字符串类型-String"><a href="#字符串类型-String" class="headerlink" title="字符串类型 String"></a>字符串类型 String</h4><p>字符串类型的变量可以指向任何字符串值。是 System.String 的别名，由 Object 派生而来。</p>
<ul>
<li>“string”</li>
<li>@”string”</li>
</ul>
<ul>
<li>字符串前面加 @ 可以将转义字符(\)当做普通字符来处理<br>@”C:\Windows” 等价于 “C:\Windows”</li>
<li>@ 字符串可以任意换行<h4 id="用户自定义类型"><a href="#用户自定义类型" class="headerlink" title="用户自定义类型"></a>用户自定义类型</h4></li>
</ul>
<ul>
<li>class</li>
<li>interface</li>
<li>delegate</li>
</ul>
<h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>指针类型的变量存储另外一种类型的内存地址。与 C C++ 中的指针一样。</p>
<h3 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h3><p>可空类型(Nullable), 可以表示在其基础类型的值范围内，再加上一个 null 值。</p>
<ul>
<li><p>?<br>单问号用于将 int, double, bool 等无法直接赋值null的类型赋值为 null。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i; // i = 0</span><br><span class="line">int? ii; // ii = null</span><br><span class="line">i = null; // Error, can&apos;t convert null to &apos;bool&apos;, because it is a value type</span><br><span class="line">ii = null; //OK</span><br></pre></td></tr></table></figure>
</li>
<li><p>??<br>Null 合并运算符 (??) 用于定义可控类型的默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int? num1 = null;</span><br><span class="line">int? num2 = 3;</span><br><span class="line">int num3;</span><br><span class="line">num3 = num1 ?? 4; //num = 4;</span><br><span class="line">num3 = num2 ?? 4; //num = num2 = 3;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>隐式类型转换是默认的转换，不会造成数据丢失。比如小的整数类型转换成大的类型，子类转换成基类。</p>
<h4 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h4><ul>
<li>强制类型转换需要用到 (type) 运算符，可能会丢失数据。</li>
<li>内置转换方法<br>使用 Convert 类 </li>
</ul>
<ul>
<li>ToBoolean</li>
<li>To…</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h3><ul>
<li>前缀标识基数， 0x 表示16进制， 0 表示八进制， 没有前缀表示十进制</li>
<li>后缀可以是 U(unsigned) 和 L(long) 的组合， 不区分大小写。<h3 id="自定义常量"><a href="#自定义常量" class="headerlink" title="自定义常量"></a>自定义常量</h3>const &lt;data_type&gt; &lt;constant_name&gt; = value;</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="基础运算符与-C-一致"><a href="#基础运算符与-C-一致" class="headerlink" title="基础运算符与 C 一致"></a>基础运算符与 C 一致</h3><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><ul>
<li>sizeof</li>
<li>typeof<br>返回对象的类型</li>
<li>is<br>判断对象是否为某一类型</li>
<li>as<br>强制转换</li>
</ul>
<h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><ul>
<li>if ..</li>
<li>if .. else ..</li>
<li>if .. else if .. else ..</li>
<li>switch(a) case v: .. break; </li>
<li>exp1 ? exp2 : exp3;</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul>
<li>for( init; condi; increa){ expr;}</li>
<li>foreach( type a in arr){expr;}<br>foreach 能一次遍历出多维数组中的值</li>
<li>while(condi) …</li>
<li>do .. while(condi)</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)</span><br><span class="line">&#123;</span><br><span class="line">   Method Body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>值传递</li>
<li><p>引用传递 (ref)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void func(ref int a)&#123;</span><br><span class="line">    a = 100;</span><br><span class="line">&#125;</span><br><span class="line">public void test(int a)&#123;</span><br><span class="line">    int a = 1; // a = 1</span><br><span class="line">    func(ref a);</span><br><span class="line">    // a = 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出参数 (out)<br>输出参数会在函数退出的时候，将方法输出数据赋给自己，从而实现返回多个数据的目的。<br>效果同上例，将关键字修改即可。 不同点在于，提供给输出参数的变量不需要赋值。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>调用自身的方法</p>
<h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><p>带有 Main 方法的类的 Main 方法。</p>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2></li>
<li>public</li>
<li>private</li>
<li>protected</li>
<li>internal<br>同一程序集内可访问</li>
<li>protected internal<br>同一程序集或派生类内可访问</li>
</ul>
<ul>
<li>程序集：被打包成的一个 exe 或 dll. </li>
<li>类的默认访问修饰符为 private</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">datatype[] arrayName;</span><br><span class="line">double[] arr = new double[10]; // 声明一个10元素的数组</span><br><span class="line">double[] arr = &#123;1, 2, 3&#125;; //声明一个数组，并给它赋值</span><br><span class="line"></span><br><span class="line">double[,] arr = &#123;&#123;1,2&#125;, &#123;2,2&#125;&#125;; // 二维数组；</span><br><span class="line">double val = arr[0,0];//访问多维数组的 0行0列</span><br><span class="line">double[,,] arr; // 三维数组</span><br><span class="line"></span><br><span class="line">double[][] a = new int[][]&#123;new int[]&#123;0,1&#125;, new int[]&#123;1,2,3&#125;&#125;;//交错数组 </span><br><span class="line">//交错数组与多维数组不一样的地方在于，每一维的数量可以不一样</span><br><span class="line">double val = a[i][j]; //访问交错数组的元素。</span><br><span class="line"></span><br><span class="line">//参数数组</span><br><span class="line">public void func( params int[] arr)&#123;&#125;;</span><br><span class="line">func(1, 2, 3, 4);</span><br><span class="line"></span><br><span class="line">//Array 类， 封装了不少方法</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><ul>
<li>结构体是值类型数据结构。</li>
<li>可以有方法，字段， 索引，熟悉，运算符方法和事件</li>
<li>可以定义构造函数，但不能定义析构函数，不能定义默认构造函数</li>
<li>不能继承其他类或结构</li>
<li>可实现一个或多个接口</li>
<li>成员不能指定为 absract, virtual, protected</li>
<li>使用 new 操作符的时候，会调用适当的构造函数来创建</li>
<li>不适用 new 操作符即可被实例化<h2 id="与类不同的地方"><a href="#与类不同的地方" class="headerlink" title="与类不同的地方"></a>与类不同的地方</h2></li>
<li>结构是值类型，类是引用类型</li>
<li>结构不支持继承</li>
<li>结构不能声明默认构造函数</li>
</ul>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举是一组命名整型常量， 由 enum 关键字声明。枚举是值类型。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>由 class 定义， 是引用类型。</li>
<li>类的默认访问类型是 internal, 成员的默认访问类型是 private 。</li>
<li>使用点运算符 (.) 来访问类的成员。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;access specifier&gt; class  class_name&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="声明周期函数"><a href="#声明周期函数" class="headerlink" title="声明周期函数"></a>声明周期函数</h3><ul>
<li>构造函数</li>
<li>析构函数</li>
<li>abstract<br>抽象类，抽象函数<br>抽象类不能实例化</li>
<li>override<br>重写父类方法是要加 override 关键字</li>
<li>不支持多继承， 可通过接口来实现</li>
<li>sealed<br>sealed 关键字标识一个类不能被继承， 抽象类不能声明为 sealed.</li>
<li>virtual<br>需要在子类中实现的方法需要添加 virtual 关键字，虚方法的调用时在运行时发生的。</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指一个接口实现多个不同的功能。</p>
<h4 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h4><p>静态多态对函数的调用在编译器就已经明确了。</p>
<ul>
<li>函数重载<br>相同函数名有多个定义， 它们接受不同的参数个数,参数类型</li>
<li>运算符重载<br>运算符重载能定义类的一些基础行为， 通过关键字 operator 后跟运算符符号来定义。<h4 id="动态多态"><a href="#动态多态" class="headerlink" title="动态多态"></a>动态多态</h4>动态多态对函数的调用需要在运行时才能确定。</li>
</ul>
<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 (interface)"></a>接口 (interface)</h2><p>接口只包含成员的声明，由派生类负责实现</p>
<h2 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间 (namespace)"></a>命名空间 (namespace)</h2><p>命名空间目的是让一组名称与其他名称分割开。<br>使用 using 关键字来引入命名空间，<br>也可以不使用 using ， 直接使用 命名空间.name 的方式来使用命名空间的成员。<br>命名空间可以嵌套</p>
<h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><ul>
<li>预处理器在实际编译之前对信息进行预处理</li>
<li>预处理器指令以 <code>#</code> 开头，只有空白字符可以出现在预处理器指令前。</li>
<li>不是语句， 不以分号结尾</li>
<li>预处理器用于实现条件编译， 不用于创建宏。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define TEST</span><br><span class="line">#if (TEST &amp;&amp; !VC_10)</span><br><span class="line">    Console.Write(&quot;TEST is defined, not VC_10&quot;);</span><br><span class="line">#elif (TEST &amp;&amp; VC_10)</span><br><span class="line"># else</span><br><span class="line"># endif</span><br><span class="line">#undef TEST </span><br><span class="line">#line  1  //修改编译器的行数</span><br><span class="line">#error    //在指定地方输出一个错误</span><br><span class="line">#warning //在指定地方输出一个警告</span><br><span class="line">#region    // 用于在代码编辑器中声明一个可展开的区块</span><br><span class="line">#endregion //结束上文定义</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><ul>
<li>\a 匹配报警符(\u0007)</li>
<li>\b 匹配退格符(\u0008)</li>
<li>\t 匹配制表符(\u0009)</li>
<li>\r 匹配回车符(\u000D)</li>
<li>\v 匹配垂直制表符(\u000B)</li>
<li>\f 匹配换页符(\u000C)</li>
<li>\n 匹配换行符(\u000A)</li>
<li>\e 匹配转义符(\u001B)<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3></li>
<li>[character_group] 匹配 group 中的所有字符，区分大小写</li>
<li>[^ …] 非， 不匹配该组字符</li>
<li>[first - last] 匹配范围内的字符</li>
<li>.  匹配除 \n 外的所有字符</li>
<li>\w 匹配任何单词字符</li>
<li>\s 匹配空白字符</li>
<li>\d 匹配十进制数字<h3 id="定位点"><a href="#定位点" class="headerlink" title="定位点"></a>定位点</h3></li>
<li>^ 匹配开头</li>
<li>\A 同上</li>
<li>$ 匹配末尾</li>
<li>\Z 同上</li>
<li>\G 上一个匹配结束的地方</li>
<li>\b 匹配单词结束的地方<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3></li>
<li>(subexpresion)  定义一个捕获组</li>
<li>(?<name>subexpression) 定义一个命名捕获组</name></li>
<li>(?:subexpression) 定义一个非捕获组<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3></li>
<li>* </li>
<li>+</li>
<li>?</li>
<li>{n}</li>
<li>{n ,}</li>
<li>{n, m}</li>
<li>限定符? 限定符的非贪婪版本<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3></li>
<li>\number 引用第 number 个捕获组</li>
<li>\k<name> 引用命名捕获组<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3>用于替换模式中的正则表达式, 主要是用 $ 来引用</name></li>
<li>$number 替换为第 number 个捕获组</li>
<li>${name} 替换为命名捕获组</li>
<li>$` 替换为输入字符串匹配前的文本</li>
<li>$’ 替换为输入字符串匹配后的文本</li>
<li>$+ 替换为最后的匹配组</li>
<li>$_ 替换为整个输入字符串</li>
<li>$&amp; 替换为整个匹配项<h3 id="Regex-类"><a href="#Regex-类" class="headerlink" title="Regex 类"></a>Regex 类</h3></li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>try{ expr.. } catch(Exception e){} finally{}<br>Throw(ex)</p>
<h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><p>文件通过流的方式与程序交互，输入流用于读取文件， 输出流用于向文件写入数据。<br>System.IO 命名空间有各种类处理文件操作。</p>
<h1 id="高级部分"><a href="#高级部分" class="headerlink" title="高级部分"></a>高级部分</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>特性用于在运行时传递程序中各种元素的行为信息的声明性标签。<br>特性用于添加元数据，如编译器指令和注释、描述、方法和类等其他信息。</p>
<h3 id="规定特性"><a href="#规定特性" class="headerlink" title="规定特性"></a>规定特性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[attribute(positional_parameters, name_parameter = value, ...)]</span><br><span class="line">element</span><br></pre></td></tr></table></figure>
<p>特性的名称和值实在方括号内规定的， 放置在它所应用的元素之前。positional_parameters 规定必须的信息， name_parameter 规定可选的信息。</p>
<h3 id="预定义特性"><a href="#预定义特性" class="headerlink" title="预定义特性"></a>预定义特性</h3><ul>
<li>AttributeUsage 描述如何使用一个自定义特性类</li>
<li><p>Conditional 标记一个条件方法，当条件为真时，调用该方法，否则跳过对该方法的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Conditional(&quot;DEBUG&quot;)]</span><br><span class="line">public static void Message(string msg)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(msg);</span><br><span class="line">&#125;</span><br><span class="line">//当没有定义 DEBUG 时，对该方法的调用为一个空调用</span><br></pre></td></tr></table></figure>
</li>
<li><p>Obsolete 标记一个不应该被程序使用的实体，如过期的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> //语法 [Obsolete( message,?iserror)]</span><br><span class="line">[Obsolete(&quot;Don&apos;t use OldMethod, use NewMethod instead&quot;, true)]</span><br><span class="line">static void OldMethod()</span><br><span class="line">&#123; </span><br><span class="line">   Console.WriteLine(&quot;It is the old method&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="自定义特性"><a href="#自定义特性" class="headerlink" title="自定义特性"></a>自定义特性</h3><p>自定义特性应该派生自 System.Attribute 类，使用 AttributeUsage 来修饰该特性的行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[AttributeUsage(AttributeTargets.Class |</span><br><span class="line">AttributeTargets.Constructor |</span><br><span class="line">AttributeTargets.Field |</span><br><span class="line">AttributeTargets.Method |</span><br><span class="line">AttributeTargets.Property,</span><br><span class="line">AllowMultiple = true)]</span><br><span class="line"></span><br><span class="line">public class DebugInfo : System.Attribute&#123;</span><br><span class="line">&#125;</span><br><span class="line">//使用</span><br><span class="line">[DebugInfo()]</span><br></pre></td></tr></table></figure></p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射指程序可以访问、检测和修改它本身状态或行为的一种能力。<br>你可以使用反射动态的创建类型的实例， 将类型绑定到现有对象，或从现有对象中获取类型，然后可以调用类型的方法或访问其字段和属性。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>反射提高了程序的灵活性和扩展性。</li>
<li>降低耦合性，提高自适应能力。</li>
<li>它允许程序创建和控制任何类的对象，无需提前硬编码目标类。<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3></li>
<li>性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。</li>
<li>使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.Reflection.MemberInfo info = typeof(MyClass);</span><br><span class="line">object[] attributes = info.GetCustomAttributes(true);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性是类结构或接口中的命名成员， 是域的扩展，它们使用访问其来私有域的值可被读写或操作。</p>
<h3 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h3><p>访问器包含用于获取或设置属性的语句，访问器声明可包含一个 get 访问器， 一个 set 访问器，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Accestor&#123;</span><br><span class="line">    private string code = &quot;N.A&quot;;</span><br><span class="line">    // 声明类型为 string 的 Code 属性</span><br><span class="line">    public string Code &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return code;</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            code = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="抽象属性"><a href="#抽象属性" class="headerlink" title="抽象属性"></a>抽象属性</h3><p>抽象类可用拥有抽象属性，这些属性应该在派生类中实习。 抽象属性只定义行为，不实现。</p>
<h2 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h2><p>索引器允许一个对象像数组一样的索引，当你为一个类定义了一个索引器之后，就可以使用数组访问运算符 ([]) 来访问类的实例。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">element-type this[int index] &#123;</span><br><span class="line">   // get 访问器</span><br><span class="line">   get &#123;</span><br><span class="line">      // 返回 index 指定的值</span><br><span class="line">   &#125;</span><br><span class="line">   // set 访问器</span><br><span class="line">   set &#123;</span><br><span class="line">      // 设置 index 指定的值 </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重载索引器"><a href="#重载索引器" class="headerlink" title="重载索引器"></a>重载索引器</h3><p>索引器声明的时候也可带有多个参数，且每个参数可以是不同类型。</p>
<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>委托类似于函数指针，存在一个对被委托函数的的引用，使用 new 关键字， 加上被委托方法作为参数来创建。调用委托时会调用被委托对象。</p>
<h3 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h3><ul>
<li>+ 运算符可以将委托进行合并。</li>
<li>- 运算符可用于从合并的委托中移除组件委托。</li>
<li>使用这个特点， 可以用一个委托代理多个方法，达到多播的效果。</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件(event)是一个用户操作， 或者说一个消息，它使用委托来与事件处理函数关联。</p>
<ul>
<li>发布器， 包含事件的类，用于发布事件。</li>
<li>订阅器， 接受事件并处理事件处理函数的类。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Publisher&#123;</span><br><span class="line">    public delegate void Handler();</span><br><span class="line">    public event Handler myEvent;</span><br><span class="line">    public void send()&#123;</span><br><span class="line">        if(myEvent != null)&#123;</span><br><span class="line">            myEvent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void subscriber()&#123;</span><br><span class="line">        Console.WriteLine(&quot;handler event&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void Main()&#123;</span><br><span class="line">        Publisher publiser = new Publisher();</span><br><span class="line">        publisher.myEvent += publisher.subscriber;</span><br><span class="line">        publisher.send(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合 (Collection) 类是专门用于数据存储和检索的类。</p>
<ul>
<li>动态数组 (ArrayList)</li>
<li>哈希表 (Hashtable)</li>
<li>排序列表 (SortedList)</li>
<li>堆栈 (Stack)</li>
<li>队列 (Queue)</li>
<li>点阵列 (BitArray)</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型用于实现一些通用的行为，在实现时用类型的替代参数编写代码。在需要构造函数或调用类的方法的时候，编译器会生成对应类型的代码来处理指定的数据类型。<br>可以通过类型参数定义泛型委托。</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名方法提供了一种使用代码块作为委托参数的技术， 您名方法中不需要指定返回类型，它会自动通过 return 语句推断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public delegate void Handler(int n);</span><br><span class="line">Handler hd = delegate(int n)&#123;expr...&#125;;</span><br><span class="line">hd(10);</span><br></pre></td></tr></table></figure></p>
<h2 id="不安全代码"><a href="#不安全代码" class="headerlink" title="不安全代码"></a>不安全代码</h2><p>当一个代码块使用 unsafe 修饰符标记时，允许在函数中使用指针。<br>不安全代码块是使用了指针变量的代码块。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>System.Threading.Thread</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vollen.github.io/2020/01/16/lang/c#/" data-id="ck5g7xyar0013wes6oh9y2h11" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-lang/go" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/16/lang/go/" class="article-date">
  <time datetime="2020-01-16T04:11:46.643Z" itemprop="datePublished">2020-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="env"><a href="#env" class="headerlink" title="env"></a>env</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go</span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/env/go/libs;<span class="variable">$HOME</span>/go</span><br></pre></td></tr></table></figure>
<h1 id="go-包获取"><a href="#go-包获取" class="headerlink" title="go 包获取"></a>go 包获取</h1><h2 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h2><p>go 的很多依赖包都是在 golang.org 上, 这个地址因为众所周知的原因, 无法直接访问。</p>
<p>首先我们需要准备一个能爬墙的梯子, 这里使用 shadowsocks。<br>点击小图标 -&gt; Http 代理设置 -&gt; http 代理开启, 记录下这里的监听地址和监听端口. 我这里是 (127.0.0.1: 1087)<br>在需要更新依赖的控制台执行以下命令, 即可设置代理. 运行 <code>go get</code> 即可安装依赖<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HTTP_PROXY=http://127.0.0.1:1087</span><br><span class="line"><span class="built_in">export</span> HTTPS_PROXY=http://127.0.0.1:1087</span><br></pre></td></tr></table></figure></p>
<h3 id="vs-code-代理设置"><a href="#vs-code-代理设置" class="headerlink" title="vs code 代理设置"></a>vs code 代理设置</h3><p>Code -&gt; 首选项 -&gt; 设置 -&gt; 应用程序 -&gt; 代理服务器 中配置<br>也可以 Cmd+Shift+P 输入 setting, 打开用户设置, 输入 <code>proxy</code> 搜索对应配置<br></p>
<h2 id="git-地址配置"><a href="#git-地址配置" class="headerlink" title="git 地址配置"></a>git 地址配置</h2><p>对于公司自己部署的<code>git</code>服务器, go 依赖模块无法解析到实际的域名. 依赖会安装失败。<br>这时候需要在 <code>~/.gitconfig</code> 配置对应的域名, 如下.<br><figure class="highlight plain"><figcaption><span>config</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[url &quot;git@git.hortorgames.com:&quot;]</span><br><span class="line">insteadOf = https://git.hortorgames.com/</span><br><span class="line">[url &quot;git@git.hortorgames.com:&quot;]</span><br><span class="line">insteadOf = http://git.hortorgames.com/</span><br></pre></td></tr></table></figure></p>
<h2 id="goland"><a href="#goland" class="headerlink" title="goland"></a>goland</h2><p>有钱了还是付费的好呀。<br><a href="http://idea.lanyus.com/" target="_blank" rel="noopener">注册码获取地址</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vollen.github.io/2020/01/16/lang/go/" data-id="ck5g7xyar0014wes6vrfq6y21" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-lang/c++" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/16/lang/c++/" class="article-date">
  <time datetime="2020-01-16T04:11:46.643Z" itemprop="datePublished">2020-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="缩窄错误"><a href="#缩窄错误" class="headerlink" title="缩窄错误"></a>缩窄错误</h1><p>当将一个范围更大的变量赋值给范围较小的变量时，如<code>int</code>到<code>short</code>, 就会出现缩窄错误。<br>但是正常赋值的话，编译不会有问题，部分编译器会有个警告，运行时可能会出现错误。</p>
<ul>
<li>使用列表初始化可以避免这种错误，它会直接在编译阶段抛出错误。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> large = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">float</span> small&#123;large&#125;; <span class="comment">//compile error</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="auto-类型推断"><a href="#auto-类型推断" class="headerlink" title="auto 类型推断"></a>auto 类型推断</h1><p>可以根据赋给变量的初值，自动推断出其类型。<br>也可用于函数返回类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> intNum = <span class="number">1</span>; <span class="comment">//int</span></span><br></pre></td></tr></table></figure></p>
<h1 id="constexpr-定义常量表达式"><a href="#constexpr-定义常量表达式" class="headerlink" title="constexpr 定义常量表达式"></a>constexpr 定义常量表达式</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">GetPi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">22.0</span> / <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">TwicePi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * GetPi();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常量表达式会在编译期间被替换为计算好的常量值。</span></span><br></pre></td></tr></table></figure>
<h1 id="lambda-函数"><a href="#lambda-函数" class="headerlink" title="lambda 函数"></a>lambda 函数</h1><p><a href="parameter list">optional parameters</a>{ statements; }</p>
<h1 id="new-和-delete"><a href="#new-和-delete" class="headerlink" title="new 和 delete"></a>new 和 delete</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用try_catch 处理分配异常。</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * huge = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0x7fffffff</span>];</span><br><span class="line">&#125;<span class="keyword">catch</span>(bad_alloc)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用判断结果指针</span></span><br><span class="line"><span class="keyword">int</span> * huge2 = <span class="keyword">new</span>(nothrow) <span class="keyword">int</span>[<span class="number">0x7fffffff</span>];</span><br><span class="line"><span class="keyword">if</span>(huge2)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"alloced successed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"alloced failed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ol>
<li>务必初始化指针变量，否则它将包含垃圾值。</li>
<li>务必仅在指针有效时才使用它，否则程序可能崩溃。</li>
<li>对于使用 new 分配的内存，一定要记得使用 delete 进行释放，否则应用程序将泄露内存.</li>
<li>指针被delete之后不应该再访问它.</li>
<li>不要对一个指针多次delete</li>
</ol>
<h2 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据const 离谁更近， 则修饰谁。</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> ptr; <span class="comment">//常指针，指针指向的地址不能被修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * ptr; <span class="comment">//指针指向的地址可以修改， 但是地址内部的内容可以修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> <span class="comment">//都不能修改</span></span><br></pre></td></tr></table></figure>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>为避免类的隐式转换，可以在构造函数前加<code>explicit</code>。</p>
<h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2><ol>
<li>当函数参数使用值传递时， 对象会被复制一份， 然后在函数内使用。</li>
<li>如果类没有复制构造函数， 那么会默认才用二进制复制的方式，指针是浅复制，可能会出问题。</li>
<li>如果有复制构造函数， 则会通过复制构造函数实现复制。</li>
<li>复制构造函数的参数必须按引用传递， 否则会不断调用自己。</li>
<li>复制构造函数的参数最好使用<code>const</code></li>
<li>除非万不得已， 不要将类成员声明为原始指针。</li>
<li>使用原始指针的情况下， 必须要写复制构造函数和复制赋值运算符。</li>
</ol>
<h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><h2 id="特殊的类"><a href="#特殊的类" class="headerlink" title="特殊的类"></a>特殊的类</h2><h3 id="禁止复制"><a href="#禁止复制" class="headerlink" title="禁止复制"></a>禁止复制</h3><p>私有的复制构造函数，私有的赋值运算符重载</p>
<h3 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h3><p>禁止复制的类， 并且私有的构造函数， 提供静态实例</p>
<h3 id="禁止在栈中实例化的类"><a href="#禁止在栈中实例化的类" class="headerlink" title="禁止在栈中实例化的类"></a>禁止在栈中实例化的类</h3><p>私有的析构函数, 并提供静态函数，在类内部delete<br>在栈中实例化的对象，出栈时自动析构， 私有的析构函数会导致析构失败。</p>
<h2 id="使用子类调用父类方法"><a href="#使用子类调用父类方法" class="headerlink" title="使用子类调用父类方法"></a>使用子类调用父类方法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当子类中只重载了父类部分函数时，未重载的同名函数会被隐藏。</span></span><br><span class="line">sub.Base::func();</span><br><span class="line"><span class="comment">//使用using关键字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Base::func;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重载所有版本</span></span><br></pre></td></tr></table></figure>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>禁止继承</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>std::thread<br>std::mutex<br>std::lock_guard<br>std::unique_lock<br>std::future<br>std::packaged_task<br>std::condition_variable</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vollen.github.io/2020/01/16/lang/c++/" data-id="ck5g7xyas0016wes65fmnojkv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-dragger-di/">-- android -- dragger -- di</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Aaron-Swartz/">Aaron Swartz</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrome/">Chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript6/">ECMAScript6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SE/">SE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/audio/">audio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/">blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2d/">cocos2d</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2dx/">cocos2dx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/database/">database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/freecodecamp/">freecodecamp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glsl/">glsl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kill/">kill</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/learn/">learn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life/">life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/makefile/">makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/media/">media</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/opengl/">opengl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openresty/">openresty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/perl/">perl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/power-shell/">power-shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/renderer/">renderer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/retransmission/">retransmission</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rules/">rules</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sdk/">sdk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/service/">service</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sqlite/">sqlite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/">ssh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sublime/">sublime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/systemstap/">systemstap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp/">tcp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/texture/">texture</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/todo/">todo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tribute/">tribute</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ui/">ui</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/url/">url</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vm/">vm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vps/">vps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/优化/">优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/信号/">信号</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/压缩/">压缩</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能测试/">性能测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/效率/">效率</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境搭建/">环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓存/">缓存</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/android-dragger-di/" style="font-size: 10px;">-- android -- dragger -- di</a> <a href="/tags/Aaron-Swartz/" style="font-size: 10px;">Aaron Swartz</a> <a href="/tags/Chrome/" style="font-size: 10px;">Chrome</a> <a href="/tags/ECMAScript6/" style="font-size: 10px;">ECMAScript6</a> <a href="/tags/SE/" style="font-size: 10px;">SE</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/audio/" style="font-size: 10px;">audio</a> <a href="/tags/blog/" style="font-size: 13.33px;">blog</a> <a href="/tags/book/" style="font-size: 10px;">book</a> <a href="/tags/cocos2d/" style="font-size: 10px;">cocos2d</a> <a href="/tags/cocos2dx/" style="font-size: 10px;">cocos2dx</a> <a href="/tags/database/" style="font-size: 16.67px;">database</a> <a href="/tags/debug/" style="font-size: 16.67px;">debug</a> <a href="/tags/freecodecamp/" style="font-size: 10px;">freecodecamp</a> <a href="/tags/git/" style="font-size: 16.67px;">git</a> <a href="/tags/glsl/" style="font-size: 10px;">glsl</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/javascript/" style="font-size: 13.33px;">javascript</a> <a href="/tags/kill/" style="font-size: 10px;">kill</a> <a href="/tags/learn/" style="font-size: 10px;">learn</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/tags/mac/" style="font-size: 10px;">mac</a> <a href="/tags/makefile/" style="font-size: 10px;">makefile</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/media/" style="font-size: 10px;">media</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/network/" style="font-size: 10px;">network</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/opengl/" style="font-size: 13.33px;">opengl</a> <a href="/tags/openresty/" style="font-size: 10px;">openresty</a> <a href="/tags/perl/" style="font-size: 10px;">perl</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/power-shell/" style="font-size: 10px;">power-shell</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/renderer/" style="font-size: 10px;">renderer</a> <a href="/tags/retransmission/" style="font-size: 10px;">retransmission</a> <a href="/tags/rules/" style="font-size: 10px;">rules</a> <a href="/tags/sdk/" style="font-size: 10px;">sdk</a> <a href="/tags/service/" style="font-size: 13.33px;">service</a> <a href="/tags/sqlite/" style="font-size: 10px;">sqlite</a> <a href="/tags/ssh/" style="font-size: 10px;">ssh</a> <a href="/tags/sublime/" style="font-size: 10px;">sublime</a> <a href="/tags/systemstap/" style="font-size: 10px;">systemstap</a> <a href="/tags/tcp/" style="font-size: 10px;">tcp</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/texture/" style="font-size: 10px;">texture</a> <a href="/tags/todo/" style="font-size: 10px;">todo</a> <a href="/tags/tools/" style="font-size: 10px;">tools</a> <a href="/tags/tribute/" style="font-size: 10px;">tribute</a> <a href="/tags/ui/" style="font-size: 10px;">ui</a> <a href="/tags/url/" style="font-size: 10px;">url</a> <a href="/tags/vm/" style="font-size: 10px;">vm</a> <a href="/tags/vps/" style="font-size: 13.33px;">vps</a> <a href="/tags/优化/" style="font-size: 10px;">优化</a> <a href="/tags/信号/" style="font-size: 10px;">信号</a> <a href="/tags/压缩/" style="font-size: 10px;">压缩</a> <a href="/tags/性能测试/" style="font-size: 10px;">性能测试</a> <a href="/tags/效率/" style="font-size: 10px;">效率</a> <a href="/tags/环境搭建/" style="font-size: 10px;">环境搭建</a> <a href="/tags/缓存/" style="font-size: 10px;">缓存</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/16/typescript/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/01/16/开源协议/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/01/16/面试整理/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/01/16/tools/开发环境使用工具/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/01/16/webserver/cross-origin/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 vollen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>